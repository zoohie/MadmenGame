import { LoaderModel, LoadEvents, SoundLoader } from "general-framework";
import { Sound } from "../../sound/Sound";
import { CoreSoundEvents } from "../../sound/events/CoreSoundEvents";
export class SlotSoundLoader extends SoundLoader {
    constructor() {
        super(...arguments);
        this.loadedMap = [];
    }
    loadLazySounds(group) {
        if (this.loadedMap.indexOf(group.id) !== -1) {
            this.checkNextLazyAsset();
            return;
        }
        let sound = new Sound({
            src: [group.url],
        });
        sound.id = group.id;
        sound.on("load", () => {
            this.dispatcher.dispatch(LoadEvents.LOAD_PROGRESS, LoaderModel.currentGroupSize(this.currentPriorityID));
            this.dispatcher.dispatch(CoreSoundEvents.MAP_SOUND, sound);
            this.loadedMap.push(sound.id);
            this.checkNextLazyAsset();
        });
    }
    loadQueue(soundsData) {
        return new Promise((resolve) => {
            this.mainInitialResolve = resolve;
            let count = 0;
            soundsData.map((item) => {
                let sound = new Sound({
                    src: [item.url],
                });
                sound.id = item.id;
                sound.on("load", () => {
                    count += 1;
                    this.dispatcher.dispatch(LoadEvents.LOAD_PROGRESS, LoaderModel.currentGroupSize(this.currentPriorityID));
                    this.dispatcher.dispatch(CoreSoundEvents.MAP_SOUND, sound);
                    this.loadedMap.push(sound.id);
                    if (count >= soundsData.length - 1) {
                        this.mainInitialResolve();
                    }
                });
            });
        });
    }
}
//# sourceMappingURL=SlotSoundLoader.js.map