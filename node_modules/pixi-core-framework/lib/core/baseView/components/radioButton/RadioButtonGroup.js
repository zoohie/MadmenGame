import { RadioButton } from "./RadioButton";
import { RadioButtonEvents } from "./RadioButtonEvents";
export class RadioButtonGroup extends PIXI.Container {
    constructor(radioValues, data, defaultValue) {
        super();
        this.radioButtons = [];
        this._defaultValue = defaultValue;
        this.create(radioValues, data);
    }
    create(radioValues, data) {
        for (let i = 0; i < radioValues.length; i++) {
            const elem = radioValues[i].toString();
            const radioButton = new RadioButton(elem, data);
            this.addChild(radioButton);
            radioButton.y = (radioButton.height + data.vOffset) * Math.floor(i / data.columns);
            radioButton.x = (radioButton.getWidth() + data.hOffset) * (i % data.columns);
            this.addCustomRadioButton(radioButton);
            this.radioButtons.push(radioButton);
        }
    }
    addCustomRadioButton(radioButton) {
        radioButton.interactive = true;
        radioButton.addListener("pointerup", (event) => {
            this.setRadioButton(event.currentTarget);
            this.emit(radioButton.isCustom ? RadioButtonEvents.RADIO_CHECKED_CUSTOM : RadioButtonEvents.RADIO_CHECKED);
        });
        if (radioButton.text === this._defaultValue) {
            this.setRadioButton(radioButton);
        }
        this.radioButtons.push(radioButton);
    }
    setValue(value, stopPropagation = false) {
        const radioButton = this.radioButtons.find((elem) => {
            return elem.text.toString() === value;
        });
        if (radioButton) {
            this.setRadioButton(radioButton);
            if (!stopPropagation) {
                this.emit(RadioButtonEvents.RADIO_CHECKED);
            }
        }
    }
    setRadioButton(radioButton) {
        this._currentRadio && this._currentRadio.setChecked(false);
        this._currentRadio = radioButton;
        this._currentRadio.setChecked(true);
    }
    setRadioButtonVisible(buttonId, visible) {
        const radioButton = this.radioButtons.find((elem) => {
            return elem.text === buttonId;
        });
        if (radioButton) {
            radioButton.visible = visible;
        }
    }
    clean() {
        if (this._defaultValue) {
            const defaultRadioButton = this.radioButtons.find((elem) => {
                return elem.text === this._defaultValue;
            });
            this.setRadioButton(defaultRadioButton);
        }
        else {
            this._currentRadio && this._currentRadio.setChecked(false);
            this._currentRadio = null;
        }
    }
    lock() {
        this.radioButtons.forEach(radioButton => {
            radioButton.interactive = false;
        });
    }
    unlock() {
        this.radioButtons.forEach(radioButton => {
            radioButton.interactive = true;
        });
    }
    get defaultValue() {
        return this._defaultValue;
    }
    get currentValue() {
        return this._currentRadio ? this._currentRadio.text : null;
    }
    setCurrentValue(value) {
        this._currentRadio.text = value;
    }
}
//# sourceMappingURL=RadioButtonGroup.js.map