var TextStyle = PIXI.TextStyle;
import { DeviceInfoService, LocalUtil } from "general-framework";
import MultiStyleText from "pixi-multistyle-text";
import { BaseViewComponent } from "./BaseViewComponent";
export class BaseLabel extends BaseViewComponent {
    constructor(data) {
        super(data);
        this.MAX_MULTISTYLE_WIDTH = 900;
        this._scaleToWidth = false;
        this._scaleToHeight = false;
        this._isMultiStyle = false;
        this._width = data.width;
        this._scaleToWidth = data.scaleToWidth;
        this._scaleToHeight = data.scaleToHeight;
        if (data.alpha !== undefined) {
            this.alpha = data.alpha;
        }
        if (data.localKey) {
            this._localKey = data.localKey;
            data.text = LocalUtil.text(this._localKey);
        }
        if (data.multiStyle) {
            this._isMultiStyle = true;
            this.dataTextStyle = data.multiStyle;
            const styles = Object.values(data.multiStyle);
            if (data.multiStyle["default"]["wordWrapWidth"] > this.MAX_MULTISTYLE_WIDTH && DeviceInfoService.isMobile) {
                const scaleFactor = this.MAX_MULTISTYLE_WIDTH / data.multiStyle["default"]["wordWrapWidth"];
                data.multiStyle["default"]["wordWrapWidth"] = this.MAX_MULTISTYLE_WIDTH;
                styles.forEach((style) => {
                    const fontSize = parseInt(style["fontSize"]);
                    style["fontSize"] = Math.round(fontSize * scaleFactor).toString() + "px";
                });
                this._textField = new MultiStyleText(data.text, data.multiStyle);
                this._textField.scale.set(1 / scaleFactor, 1 / scaleFactor);
            }
            else {
                this._textField = new MultiStyleText(data.text, data.multiStyle);
            }
            if (Object.values(data.multiStyle).find((elem) => {
                return elem["link"] !== undefined;
            })) {
                this.findMultiStyleTextPosition(this._textField);
            }
        }
        else {
            let style = new TextStyle(data);
            this._textField = new PIXI.Text(data.text, style);
        }
        if (data.height) {
            this._height = data.height;
        }
        else {
            this._height = this._textField.height;
        }
        if (data.angle !== undefined) {
            this.rotation = data.angle * (Math.PI / 180);
        }
        this._sourceText = data.text;
        if (this.sourceData.showBound) {
            this.drawBound();
        }
        this.align = this.sourceData.align;
        this.vAlign = this.sourceData.vAlign;
        this.alignText();
        this.addChild(this._textField);
    }
    drawBound() {
        let graphics = new PIXI.Graphics();
        graphics.beginFill(0xFFFF00, 0);
        graphics.lineStyle(1, 0xFF0000);
        graphics.drawRect(0, 0, this.width, this.height);
        graphics.endFill();
        this.addChild(graphics);
    }
    init() {
    }
    onAdded() {
    }
    get groupID() {
        return this._groupID;
    }
    get sourceData() {
        return this._sourceData;
    }
    get layoutID() {
        return this._layoutID;
    }
    get textField() {
        return this._textField;
    }
    get width() {
        return this._width;
    }
    set width(value) {
        this._width = value;
    }
    get align() {
        return this._align;
    }
    set align(value) {
        this._align = value;
    }
    get vAlign() {
        return this._vAlign;
    }
    set vAlign(value) {
        this._vAlign = value;
    }
    get isCustom() {
        return this._isCustom;
    }
    set isCustom(value) {
        this._isCustom = value;
    }
    get scaleToWidth() {
        return this._scaleToWidth;
    }
    set scaleToWidth(value) {
        this._scaleToWidth = value;
    }
    setText(value, setLeft = false) {
        if (setLeft) {
            this._textField.text = value + this._sourceText;
        }
        else {
            this._textField.text = this._sourceText + value;
        }
        this.alignText();
    }
    alignText() {
        this._textField.style.fontSize = Number(this.sourceData.fontSize);
        this._textField.y = this._height / 2 - this._textField.height / 2;
        if (this._scaleToWidth && this._textField.width > this.width) {
            this.selectFontSize();
        }
        if (this._scaleToHeight && this._textField.height > this.height) {
            this.selectFontSize();
        }
        const textFieldWidth = this._textField.getLocalBounds().width;
        switch (this.align) {
            case "left":
                this._textField.x = 0;
                break;
            case "center":
                this._textField.x = this.width / 2 - textFieldWidth / 2;
                break;
            case "right":
                this._textField.x = this.width - textFieldWidth;
                break;
        }
        switch (this.vAlign) {
            case "top":
                this._textField.y = 0;
                break;
            case "center":
                this._textField.y = this.height / 2 - this._textField.height / 2;
                break;
            case "bottom":
                this._textField.y = this.height - this._textField.height;
                break;
        }
    }
    setVisible(value) {
        this.visible = value;
    }
    selectFontSize() {
        this._textField.style.fontSize = Number(this._textField.style.fontSize) - 1;
        this._textField.y = this._height / 2 - this._textField.height / 2;
        if (this._scaleToWidth && this._textField.width > this.width && Number(this._textField.style.fontSize) > 7) {
            this.selectFontSize();
        }
        if (this._scaleToHeight && this._textField.height > this.height && Number(this._textField.style.fontSize) > 7) {
            this.selectFontSize();
        }
    }
    get height() {
        return this._height;
    }
    findMultiStyleTextPosition(textField) {
        let outputText;
        if (textField["_style"].wordWrap) {
            outputText = textField["wordWrap"](textField.text);
        }
        // split text into lines
        let lines = outputText.split(/(?:\r\n|\r|\n)/);
        // get the text data with specific styles
        let outputTextData = textField["_getTextDataPerLine"](lines);
        // calculate text width and height
        let lineWidths = [];
        let lineYMins = [];
        let lineYMaxs = [];
        let maxLineWidth = 0;
        for (let i = 0; i < lines.length; i++) {
            let lineWidth = 0;
            let lineYMin = 0;
            let lineYMax = 0;
            for (let j = 0; j < outputTextData[i].length; j++) {
                let sty = outputTextData[i][j].style;
                // save the width
                outputTextData[i][j].width = textField.context.measureText(outputTextData[i][j].text).width;
                if (outputTextData[i][j].text.length !== 0) {
                    outputTextData[i][j].width += (outputTextData[i][j].text.length - 1) * sty.letterSpacing;
                    if (j > 0) {
                        lineWidth += sty.letterSpacing / 2; // spacing before first character
                    }
                    if (j < outputTextData[i].length - 1) {
                        lineWidth += sty.letterSpacing / 2; // spacing after last character
                    }
                }
                lineWidth += outputTextData[i][j].width;
                // save the font properties
                outputTextData[i][j].fontProperties = PIXI.TextMetrics.measureFont(textField.context.font);
                // save the height
                outputTextData[i][j].height = outputTextData[i][j].fontProperties.fontSize;
                if (typeof sty.valign === "number") {
                    lineYMin =
                        Math.min(lineYMin, sty.valign
                            - outputTextData[i][j].fontProperties.descent);
                    lineYMax =
                        Math.max(lineYMax, sty.valign
                            + outputTextData[i][j].fontProperties.ascent);
                }
                else {
                    lineYMin =
                        Math.min(lineYMin, -outputTextData[i][j].fontProperties.descent);
                    lineYMax =
                        Math.max(lineYMax, outputTextData[i][j].fontProperties.ascent);
                }
            }
            lineWidths[i] = lineWidth;
            lineYMins[i] = lineYMin;
            lineYMaxs[i] = lineYMax;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        let reducedY = 0;
        // Compute the drawing data
        for (let i = 0; i < outputTextData.length; i++) {
            let line = outputTextData[i];
            let finalX = 0;
            let finalHeight = 0;
            for (let j = 0; j < line.length; j++) {
                let { style, text, fontProperties, width, height, tag } = line[j];
                if (style["link"]) {
                    const graphics = new PIXI.Graphics();
                    graphics.beginFill(0xFFFF00, 0);
                    graphics.lineStyle(1, 0xFF0000, 0);
                    graphics.drawRect(finalX, reducedY, line[j]["width"], line[j]["height"]);
                    graphics.endFill();
                    graphics.interactive = true;
                    graphics.buttonMode = true;
                    graphics.on("pointerup", () => {
                        const win = window.open(style["link"], '_blank');
                        win.focus();
                    });
                    textField.addChild(graphics);
                }
                finalHeight = height;
                finalX += width + style.letterSpacing / 2;
            }
            reducedY += finalHeight;
        }
    }
}
//# sourceMappingURL=BaseLabel.js.map