import 'pixi-spine/bin/pixi-spine';
import { EnterFrameManager } from "../../engine/renderer/EnterFrameManager";
import { TextureHolder } from "../../utils/layouts/TextureHolder";
import { SpineFactory } from "../factories/SpineFactory";
import { BaseViewComponent } from "./BaseViewComponent";
export class BaseSpineComponent extends BaseViewComponent {
    constructor() {
        super(...arguments);
        this.initIsComplete = false;
        this._isActive = false;
        this._listeners = {};
    }
    get isActive() {
        return this._isActive;
    }
    init() {
        if (this.initIsComplete) {
            return;
        }
        this._skeletonData = this.createSkeletonData();
        this.createSpineMovie(this._skeletonData);
        this.initIsComplete = true;
    }
    createSkeletonData() {
        const textures = TextureHolder.getTextureMap(SpineFactory.getInstance().getSkeletonData(this.layoutID), PIXI.utils.TextureCache);
        const atlas = new PIXI.spine.core.TextureAtlas(null, null, null);
        atlas.addTextureHash(textures, true);
        const atlasLoader = new PIXI.spine.core.AtlasAttachmentLoader(atlas);
        const jsonParser = new PIXI.spine.core.SkeletonJson(atlasLoader);
        const data = jsonParser.readSkeletonData(SpineFactory.getInstance().getSkeletonData(this.layoutID));
        return data;
    }
    createSpineMovie(data) {
        if (!data) {
            data = this.createSkeletonData();
        }
        this._clip = new PIXI.spine.Spine(data);
        this._clip.autoUpdate = false;
    }
    onEnterFrame(deltaTime) {
        if (this._clip && this._clip.skeleton) {
            this._clip.update(deltaTime);
            this.isOnPause = false;
            if (!this.parent) {
                this.removeClip();
            }
        }
    }
    removeClip() {
        if (this._clip.state) {
            this._clip.state.removeListener(this);
        }
        // set timeout cause of PIXI Spine trouble. At first it updates it's state (and dispatch event that clip is ended) then
        // works with it's skeleton.
        // So we should destroy Spine after it finishes work with skeleton but before next tick
        setTimeout(() => {
            if (this._clip.skeleton) {
                this._clip.destroy();
            }
        }, 1);
        this._isActive = false;
        this.removeChildren();
        EnterFrameManager.instance.removeListener(this);
    }
    playAnimation(name, isLoop, callback) {
        if (!this._isActive) {
            this.activateAnimation();
        }
        this.onCompleteCallback = null;
        if (callback) {
            this.onCompleteCallback = callback;
        }
        this._clip.skeleton.setToSetupPose();
        this._clip.state.setAnimation(0, name, isLoop);
        this._clip.update(0);
    }
    pause() {
        this.isOnPause = true;
        EnterFrameManager.instance.removeListener(this);
        this._isActive = false;
        this._clip.autoUpdate = false;
    }
    resume() {
        this._isActive = true;
        if (this.isOnPause) {
            this.isOnPause = false;
            EnterFrameManager.instance.addListener(this);
        }
        this._clip.autoUpdate = true;
    }
    addSpineEventListener(event, callback) {
        this._listeners[event] = callback;
    }
    removeSpineEventListener(event) {
        delete this._listeners[event];
    }
    removeCompleteCollback() {
        this.onCompleteCallback = null;
    }
    cheaterSetVisibility(value) {
        if (this._isActive) {
            this._clip.visible = value;
        }
    }
    activateAnimation() {
        this._isActive = true;
        this._clip.state.addListener(this);
        EnterFrameManager.instance.addListener(this);
        this._clip.state.onEvent = (i, event) => {
            if (this._listeners[event.stringValue]) {
                this._listeners[event.stringValue]();
            }
        };
        this.addChild(this._clip);
    }
    start(entry) {
    }
    interrupt(entry) {
    }
    end(entry) {
    }
    dispose(entry) {
    }
    complete(entry) {
        if (this.onCompleteCallback) {
            this.onCompleteCallback();
        }
    }
    get skeletonData() {
        return this._skeletonData;
    }
    get clip() {
        return this._clip;
    }
    event(entry, event) {
    }
    onAdded() {
        throw new Error("Method not implemented.");
    }
    destroy() {
        throw new Error("Method not implemented.");
    }
    get sourceData() {
        return this._sourceData;
    }
}
//# sourceMappingURL=BaseSpineComponent.js.map