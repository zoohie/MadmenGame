import { AppLogger } from "general-framework";
/**
 * Framework logic part
 */
export class CoreTimer {
    constructor(callback, delay, args) {
        this.callback = callback;
        this.args = args;
        this.startId = this.remainingId = delay;
        this.resume();
    }
    destroy() {
        this.pause();
    }
    pause() {
        this.timerId && clearTimeout(this.timerId);
        this.remainingId -= Date.now() - this.startId;
    }
    resume() {
        this.startId = Date.now();
        this.timerId && clearTimeout(this.timerId);
        AppLogger.log(` COreTimer started: ${this.args.toString()}`);
        this.timerId = setTimeout((...args) => {
            if (CoreTimer.isPaused) {
                return;
            }
            CoreTimer.kill(this);
            AppLogger.log(` COreTimer ended: ${this.args.toString()}`);
            this.callback(args);
        }, this.remainingId, this.args);
    }
    /**
     * create new CoreTimer instance and start it immediately
     * setTimeout or setInterval is forbidden
     * @param callback - callback function
     * @param delay - delay in ms
     * @param args
     */
    static start(callback, delay, ...args) {
        const timer = new CoreTimer(callback, delay, args);
        if (CoreTimer.isPaused) {
            timer.pause();
        }
        this.timers.push(timer);
        return timer;
    }
    /**
     * pause all timers
     */
    static pauseAll() {
        if (CoreTimer.isPaused) {
            return;
        }
        CoreTimer.isPaused = true;
        this.timers.forEach((timer) => {
            timer.pause();
        });
    }
    /**
     * resume all timers
     */
    static resumeAll() {
        if (!CoreTimer.isPaused) {
            return;
        }
        CoreTimer.isPaused = false;
        this.timers.forEach((timer) => {
            timer.resume();
        });
    }
    /**
     * kill timer, clear memory
     * @param timer
     */
    static kill(timer) {
        const index = this.timers.indexOf(timer);
        this.timers.splice(index, 1);
        timer.destroy();
    }
    /**
     * skip timer, call its callback
     * @param timer
     */
    static skip(timer) {
        timer.callback();
        this.kill(timer);
    }
}
CoreTimer.timers = [];
CoreTimer.isPaused = false;
//# sourceMappingURL=CoreTimer.js.map