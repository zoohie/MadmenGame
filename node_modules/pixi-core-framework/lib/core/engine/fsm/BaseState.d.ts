import { SlotEventDispatcher } from "../eventDispatcher/SlotEventDispatcher";
import { BaseAction } from "./BaseAction";
export declare abstract class BaseState {
    protected _id: string;
    protected permittedStates: string[];
    protected dispatcher: SlotEventDispatcher;
    protected actions: BaseAction[];
    protected executedQueue: BaseAction[];
    protected shouldSkip: boolean;
    protected isActive: boolean;
    protected mainResolve: Function;
    protected currentAction: BaseAction;
    constructor(_id: string, permittedStates: string[]);
    /**
     * This method is called just after FSM switches to this state
     */
    start(): Promise<string>;
    /**
     * Fill states with actions.
     * Use Serial and Parallel actions to wrap your actions.
     * Example:
     * return[
     *    createInstance(SerialAction, [
     *      createInstance(LoadConfigAction),
     *      createInstance(InitAppAction),
     *      createInstance(LoadAssetPreloadAction),
     *      createInstance(LoadSoundPreloadAction),
     *      createInstance(SendInitServerRequestAction),
     *      createInstance(LoadAssetInitAction),
     *      createInstance(LoadSoundInitAction),
     *      createInstance(LoadAssetLazyAction),
     *      createInstance(LoadSoundLazyAction)
     *  ]
     * )
     * ]
     */
    abstract addActions(): BaseAction[];
    /**
     * Describe logic for switching to next state.
     *
     */
    abstract getNextState(): string;
    /**
     * return state id
     */
    readonly id: string;
    skip(): void;
    onEnd(): void;
    protected execute(): Promise<void>;
    protected executeActionFromQueue(): void;
    protected isSkipped(): boolean;
}
