import * as tslib_1 from "tslib";
import { getDispatcher } from "../createInstance";
import { AppLogger } from "../../utils/logger/AppLogger";
import { AppLoggerMessageType } from "../../utils/logger/AppLoggerMessageType";
export class BaseState {
    constructor(_id, permittedStates) {
        this._id = _id;
        this.permittedStates = permittedStates;
        this.actions = [];
        this.executedQueue = [];
        this.shouldSkip = false;
        this.isActive = false;
        this.dispatcher = getDispatcher(this);
        this.actions = this.addActions();
    }
    /**
     * This method is called just after FSM switches to this state
     */
    start() {
        this.isActive = true;
        return new Promise(resolve => {
            this.execute().then(() => {
                this.isActive = false;
                this.shouldSkip = false;
                const nextState = this.getNextState();
                if (this.permittedStates.indexOf(nextState) !== -1) {
                    resolve(nextState);
                }
                else {
                    AppLogger.log(`you can't switch to  ${nextState} from  ${this.id}`, AppLoggerMessageType.ERROR);
                }
            });
        });
    }
    /**
     * return state id
     */
    get id() {
        return this._id;
    }
    skip() {
        this.shouldSkip = true;
        this.currentAction.skip();
    }
    onEnd() {
    }
    execute() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.isSkipped()) {
                return Promise.resolve();
            }
            else {
                return new Promise(resolve => {
                    this.executedQueue = this.actions.concat();
                    this.executeActionFromQueue();
                    this.mainResolve = resolve;
                });
            }
        });
    }
    executeActionFromQueue() {
        if (this.executedQueue.length === 0 || this.shouldSkip) {
            this.mainResolve();
            return;
        }
        this.currentAction = this.executedQueue.shift();
        this.currentAction.execute().then(() => {
            this.executeActionFromQueue();
        });
    }
    isSkipped() {
        return false;
    }
}
//# sourceMappingURL=BaseState.js.map