import * as PIXI from "pixi.js";
import { FX } from 'revolt-fx';
import { EnterFrameManager } from "../../engine/renderer/EnterFrameManager";
export class ParticleEmitterContainer extends PIXI.Container {
    constructor() {
        super(...arguments);
        this._afterTime = 2000;
        this._subEmitters = [];
    }
    create(data, emitterName, startSubEmitterName, endSubEmitterName) {
        this.revolt = new FX();
        this.revolt.initBundle(data);
        this.emitter = this.revolt.getParticleEmitter(emitterName);
        this.particlesContainer = new PIXI.Container();
        this.emitter.init(this.particlesContainer);
        this.emitter.on.particleSpawned.add(particle => {
            //Register for an update signal for that particle
            particle.on.updated.add(particle => {
                if (particle.time === 0 && startSubEmitterName) {
                    const startSubEmitter = this.revolt.getParticleEmitter(startSubEmitterName);
                    startSubEmitter.init(this.particlesContainer);
                    startSubEmitter.x = particle.x;
                    startSubEmitter.y = particle.y;
                    this._subEmitters.push(startSubEmitter);
                }
            });
            //Register for a died signal for that particle
            particle.on.died.add(particle => {
                if (endSubEmitterName) {
                    const endSubEmitter = this.revolt.getParticleEmitter(endSubEmitterName);
                    endSubEmitter.init(this.particlesContainer);
                    endSubEmitter.x = particle.x;
                    endSubEmitter.y = particle.y;
                    this._subEmitters.push(endSubEmitter);
                }
            });
        });
        this.addChild(this.particlesContainer);
    }
    updateEmitter() {
        this.isActive = true;
        this.emitter.update(0);
        this._subEmitters.forEach((subEmitter) => {
            subEmitter.update(0);
        });
        EnterFrameManager.instance.addListener(this);
    }
    updatePosition() {
    }
    stopEmitter() {
        this.isActive = false;
        this.emitter.stop();
        this._subEmitters.forEach((subEmitter) => {
            subEmitter.stop();
        });
        setTimeout(() => {
            EnterFrameManager.instance.addListener(this);
            this.emitter.dispose();
            this._subEmitters.forEach((subEmitter) => {
                subEmitter.dispose();
            });
            this.revolt = null;
            this.removeChild(this.particlesContainer);
        }, this._afterTime);
    }
    onEnterFrame(deltaTime) {
        this.updatePosition();
        this.emitter.update(deltaTime);
        this._subEmitters.forEach((subEmitter) => {
            subEmitter.update(deltaTime);
        });
    }
    onEmitterCompleted() {
        if (this.onEmitterCompletedDelegate) {
            this.onEmitterCompletedDelegate();
        }
    }
    onEmitterExhausted() {
        if (this.onEmitterCompletedDelegate) {
            this.onEmitterCompletedDelegate();
        }
    }
    onParticleDied() {
        if (this.onEmitterCompletedDelegate) {
            this.onEmitterCompletedDelegate();
        }
    }
    get afterTime() {
        return this._afterTime;
    }
    set afterTime(value) {
        this._afterTime = value;
    }
    get onEmitterCompletedDelegate() {
        return this._onEmitterCompletedDelegate;
    }
    set onEmitterCompletedDelegate(value) {
        this._onEmitterCompletedDelegate = value;
    }
}
//# sourceMappingURL=ParticleEmitterContainer.js.map