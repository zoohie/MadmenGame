import { EnterFrameManager } from "../../engine/renderer/EnterFrameManager";
import { TweenLite } from "gsap";
import * as PIXI from "pixi.js";
import { VerticalScrollEvents } from "./VerticalScrollEvents";
import { BaseController } from "../../engine/BaseController";
import { DeviceInfoService } from "general-framework";
export class VerticalScrollComponent extends BaseController {
    constructor() {
        super(...arguments);
        this.END_SCROLL_DURATION = .5;
        this.STEP_MULTIPLIER = .05;
        this.STEP_UPDATE = .4;
        this._drag_started = false;
        this.isStopped = true;
        this.lastPositionY = 0;
        this.MIN_SWIPE_TIME = 400;
        this._width = 0;
        this._height = 0;
        this._sliderSpeed = 0;
        this.isFirstDragStartCall = false;
    }
    get drag_started() {
        return this._drag_started;
    }
    get useScrollByTouch() {
        return this._useScrollByTouch;
    }
    set useScrollByTouch(value) {
        this._useScrollByTouch = value;
    }
    set sliderSpeed(value) {
        this._sliderSpeed = value;
    }
    set useSlider(value) {
        this._useSlider = value;
    }
    get source() {
        return this._source;
    }
    init(initData) {
        this._defaultScrollDuration = initData.defaultScrollDuration;
        const endPointSuffix = initData.endPointSuffix || 0;
        const endUpPoint = initData.endUpPoint || 0;
        this._source = initData.clip;
        this.rectangle = this.drawRectangle(initData.width, initData.height);
        this.endDownPoint = -this._source.height + endPointSuffix;
        this.endPointSuffix = endPointSuffix;
        this.endUpPoint = endUpPoint;
        this._source.addChildAt(this.rectangle, 0);
    }
    updateRectangle(x = 0, y = 0, width = this._width, height = this._height) {
        this.rectangle.x = x;
        this.rectangle.y = y;
        this.rectangle.height = height;
        this.rectangle.width = width;
    }
    useScrollBar(bar) {
        this.scrollBar = bar;
    }
    updateScrollEndPoint(value) {
        this.endDownPoint = value + this.endPointSuffix;
    }
    turnOnScroll(useDefaultScrollPosition = false, setCurrentPosition) {
        if (DeviceInfoService.isDesktop) {
            this.dispatcher.addListener(VerticalScrollEvents.ON_WHEEL_DELTA, this.scrollWheel.bind(this));
            if (this._useSlider) {
                this.scrollBar.slider.buttonMode = true;
                this.scrollBar.slider.on('pointerdown', this.onDragStart.bind(this));
                this.scrollBar.slider.on('pointerup', this.onDragEnd.bind(this));
                this.scrollBar.slider.on('pointerupoutside', this.onDragEnd.bind(this));
                this.scrollBar.slider.on('pointermove', this.onDrag.bind(this));
            }
            if (this.useScrollByTouch) {
                this.turnOnScrollByTouch();
            }
        }
        else {
            this.turnOnScrollByTouch();
        }
        if (setCurrentPosition) {
            this._source.y = setCurrentPosition;
            return;
        }
        if (useDefaultScrollPosition) {
            this._source.y = 0;
        }
    }
    turnOnScrollByTouch() {
        this._source.on('pointerdown', this.onDragStart.bind(this));
        this._source.on('pointerup', this.onDragEnd.bind(this));
        this._source.on('pointerupoutside', this.onDragEnd.bind(this));
        this._source.on('pointermove', this.onDrag.bind(this));
        this._source.interactive = true;
        this._source.buttonMode = true;
        this._drag_started = false;
        this.isStopped = true;
    }
    turnOffScrollByTouch() {
        this._source.off('pointerdown', this.onDragStart.bind(this));
        this._source.off('pointerup', this.onDragEnd.bind(this));
        this._source.off('pointerupoutside', this.onDragEnd.bind(this));
        this._source.off('pointermove', this.onDrag.bind(this));
        this._source.interactive = false;
        this._source.buttonMode = false;
    }
    turnOffScroll(useDefaultScrollPosition = false) {
        if (DeviceInfoService.isDesktop) {
            this.dispatcher.removeListener(VerticalScrollEvents.ON_WHEEL_DELTA, this.scrollWheel);
            if (this._useSlider) {
                this.scrollBar.slider.off('pointerdown', this.onDragStart.bind(this));
                this.scrollBar.slider.off('pointerup', this.onDragEnd.bind(this));
                this.scrollBar.slider.off('pointerupoutside', this.onDragEnd.bind(this));
                this.scrollBar.slider.off('pointermove', this.onDrag.bind(this));
            }
            if (this.useScrollByTouch) {
                this.turnOffScrollByTouch();
            }
        }
        else {
            this.turnOffScrollByTouch();
        }
        if (useDefaultScrollPosition) {
            this._source.y = 0;
        }
        EnterFrameManager.instance.removeListener(this);
    }
    scrollWheel(obj) {
        if (!obj) {
            return;
        }
        let source = this._source;
        if (this._useSlider) {
            source = this.scrollBar.slider;
        }
        let newY;
        newY = source.y + obj.delta;
        if (this._useSlider) {
            let speed = this._source.height / this._sliderSpeed;
            if (obj.delta > 0) {
                speed = -speed;
            }
            newY = source.y + speed;
            source.y = newY;
            if (source.y < 0) {
                source.y = 0;
            }
            else if (source.y > this.scrollBar.background.height - source.height) {
                source.y = this.scrollBar.background.height - source.height;
            }
            this.updateSourcePosition(source.y);
        }
        else {
            if (newY < this.endDownPoint) {
                newY = this.endDownPoint;
            }
            else if (newY > this.endUpPoint) {
                newY = this.endUpPoint;
            }
            this.updateSourcePosition(newY);
        }
    }
    onDragStart(e) {
        if (this._drag_started) {
            return;
        }
        this.touchStartTime = new Date().getTime();
        EnterFrameManager.instance.removeListener(this);
        let source = this._source;
        if (this._useSlider) {
            source = this.scrollBar.slider;
        }
        this.lastPositionY = source.y;
        this._drag_started = true;
        this.isFirstDragStartCall = true;
        this.drag_y = e.data.global.y;
    }
    onDrag(e) {
        if (!this.isStopped || !this._drag_started) {
            return;
        }
        let source = this._source;
        if (this._useSlider) {
            source = this.scrollBar.slider;
        }
        const newY = (e.data.global.y - this.drag_y) / source.worldTransform.a;
        source.y = this.lastPositionY + newY;
        // add sensitive 10px , to allow small movement
        if (Math.abs(newY) > 10 && this.isFirstDragStartCall) {
            this.onDragStartDelegate && this.onDragStartDelegate();
            this.isFirstDragStartCall = false;
        }
        if (this._useSlider) {
            if (source.y < 0) {
                source.y = 0;
            }
            else if (source.y > this.scrollBar.background.height - source.height) {
                source.y = this.scrollBar.background.height - source.height;
            }
            this.updateSourcePosition(source.y);
        }
    }
    onDragEnd(e) {
        this._drag_started = false;
        this.isStopped = false;
        this.onDragEndDelegate && this.onDragEndDelegate();
        let source = this._source;
        if (this._useSlider) {
            source = this.scrollBar.slider;
        }
        if (source.y < this.endDownPoint) {
            this.endScrollPages(this.endDownPoint);
            return;
        }
        if (source.y > this.endUpPoint) {
            this.endScrollPages(this.endUpPoint);
            return;
        }
        let isSwipe = false;
        const swipeTime = Date.now() - this.touchStartTime;
        if (swipeTime < this.MIN_SWIPE_TIME) {
            isSwipe = true;
        }
        if (!isSwipe) {
            this.isStopped = true;
            this.lastPositionY = source.y;
            return;
        }
        const newY = (e.data.global.y - this.drag_y) / this._source.worldTransform.a;
        this.currentStep = Math.abs(this.lastPositionY - source.y) * this.STEP_MULTIPLIER;
        if (newY < 0) {
            this.isScrollingUp = false;
        }
        else {
            this.isScrollingUp = true;
        }
        this.isStopped = true;
        EnterFrameManager.instance.addListener(this);
    }
    endScrollPages(endPoint) {
        if (this._useSlider) {
            this.isStopped = true;
            return;
        }
        this.tween && this.tween.kill();
        this.tween = TweenLite.to(this._source, this.END_SCROLL_DURATION, {
            y: endPoint,
            onComplete: () => {
                this.lastPositionY = this._source.y;
                this.isStopped = true;
            }
        });
    }
    onEnterFrame(deltaTime) {
        let value = this.onUpdate();
        if (this.isScrollingUp) {
            this.updateScrollingUP(value);
        }
        else {
            this.updateScrollingDown(value);
        }
        this.lastPositionY = this._source.y;
        if (value === 0) {
            EnterFrameManager.instance.removeListener(this);
        }
    }
    updateScrollingDown(value) {
        this._source.emit(VerticalScrollEvents.DRAG, value);
        this._source.y -= value;
        if (this._source.y < this.endDownPoint) {
            EnterFrameManager.instance.removeListener(this);
            this.endScrollPages(this.endDownPoint);
            return;
        }
    }
    updateScrollingUP(value) {
        this._source.emit(VerticalScrollEvents.DRAG, -value);
        this._source.y += value;
        if (this._source.y > this.endUpPoint) {
            EnterFrameManager.instance.removeListener(this);
            this.endScrollPages(this.endUpPoint);
            return;
        }
    }
    onUpdate() {
        this.currentStep -= this.STEP_UPDATE;
        if (this.currentStep <= 0) {
            this.currentStep = 0;
        }
        return this.currentStep;
    }
    drawRectangle(width, height) {
        this._width = this._source.width;
        this._height = this._source.height;
        if (width) {
            this._width = width;
        }
        if (height) {
            this._height = height;
        }
        let rect = new PIXI.Graphics();
        rect.beginFill(0x00ff00);
        rect.drawRect(0, 0, this._width, this._height);
        rect.endFill();
        rect.alpha = 0;
        rect.interactive = true;
        return rect;
    }
    updateSourcePosition(value) {
        if (this._tween) {
            this._tween.kill();
        }
        let result;
        if (this._useSlider) {
            let percent = (-value / (this.scrollBar.background.height - this.scrollBar.slider.height)) * 100;
            result = ((((Math.abs(this.endDownPoint))) * percent) / 100) + this.endUpPoint;
        }
        else {
            result = value;
        }
        this._tween = TweenLite.to(this._source, this._defaultScrollDuration, {
            y: result,
            onComplete: () => {
                this._tween.kill();
            }
        });
    }
}
//# sourceMappingURL=VerticalScrollComponent.js.map