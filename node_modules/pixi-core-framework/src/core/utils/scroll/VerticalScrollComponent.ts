import {EnterFrameManager, IFrameListener} from "../../engine/renderer/EnterFrameManager";
import {TweenLite} from "gsap";
import * as PIXI from "pixi.js"
import Container = PIXI.Container;
import Graphics = PIXI.Graphics;
import {VerticalScrollEvents} from "./VerticalScrollEvents";
import {BaseController} from "../../engine/BaseController";
import {ScrollBarComponent} from "./ScrollBarComponent";
import {DeviceInfoService} from "general-framework";
import {IVerticalScrollInitData} from "./IVerticalScrollInitData";

export class VerticalScrollComponent extends BaseController implements IFrameListener {

    public get drag_started(): boolean {
        return this._drag_started;
    }

    public get useScrollByTouch(): boolean {
        return this._useScrollByTouch;
    }

    public set useScrollByTouch(value: boolean) {
        this._useScrollByTouch = value;
    }
    public set sliderSpeed(value: number) {
        this._sliderSpeed = value;
    }

    public set useSlider(value: boolean) {
        this._useSlider = value;
    }

    public get source(): PIXI.Container {
        return this._source;
    }

    public END_SCROLL_DURATION: number = .5;
    public STEP_MULTIPLIER: number = .05;
    public STEP_UPDATE: number = .4;
    protected _drag_started: boolean = false;
    protected isStopped: boolean = true;
    protected drag_y: number;
    protected lastPositionY: number = 0;
    protected tween: TweenLite;
    protected MIN_SWIPE_TIME: number = 400;
    private _source: Container;

    private isScrollingUp: boolean;
    private endUpPoint: number;
    private endDownPoint: number;
    private currentStep: number;
    private touchStartTime: number;
    private endPointSuffix: number;
    private _width: number = 0;
    private _height: number = 0;
    private rectangle: Graphics;
    private _tween: TweenLite;
    private scrollBar: ScrollBarComponent;
    private _useSlider: boolean;
    private _useScrollByTouch: boolean;
    private _sliderSpeed: number = 0;
    private _defaultScrollDuration;

    public onDragStartDelegate: Function;
    public onDragEndDelegate: Function;
    protected isFirstDragStartCall: boolean = false;

    public init(initData: IVerticalScrollInitData): void {
        this._defaultScrollDuration = initData.defaultScrollDuration;
        const endPointSuffix:number = initData.endPointSuffix || 0;
        const endUpPoint:number = initData.endUpPoint || 0;
        this._source = initData.clip;
        this.rectangle = this.drawRectangle(initData.width, initData.height);
        this.endDownPoint = -this._source.height + endPointSuffix;
        this.endPointSuffix = endPointSuffix;
        this.endUpPoint = endUpPoint;
        this._source.addChildAt(this.rectangle, 0);
    }

    public updateRectangle(x: number = 0, y: number = 0, width: number = this._width, height: number = this._height): void {
        this.rectangle.x = x;
        this.rectangle.y = y;
        this.rectangle.height = height;
        this.rectangle.width = width;
    }

    public useScrollBar(bar: ScrollBarComponent): void {
        this.scrollBar = bar;
    }

    public updateScrollEndPoint(value: number): void {
        this.endDownPoint = value + this.endPointSuffix;
    }

    public turnOnScroll(useDefaultScrollPosition: boolean = false, setCurrentPosition?: number): void {
        if (DeviceInfoService.isDesktop) {
            this.dispatcher.addListener(VerticalScrollEvents.ON_WHEEL_DELTA, this.scrollWheel.bind(this));
            if (this._useSlider) {
                this.scrollBar.slider.buttonMode = true;
                this.scrollBar.slider.on('pointerdown', this.onDragStart.bind(this));
                this.scrollBar.slider.on('pointerup', this.onDragEnd.bind(this));
                this.scrollBar.slider.on('pointerupoutside', this.onDragEnd.bind(this));
                this.scrollBar.slider.on('pointermove', this.onDrag.bind(this));
            }
            if (this.useScrollByTouch) {
                this.turnOnScrollByTouch();
            }
        } else {
            this.turnOnScrollByTouch();
        }

        if (setCurrentPosition) {
            this._source.y = setCurrentPosition;
            return;
        }
        if (useDefaultScrollPosition) {
            this._source.y = 0;
        }
    }

    protected turnOnScrollByTouch(): void {
        this._source.on('pointerdown', this.onDragStart.bind(this));
        this._source.on('pointerup', this.onDragEnd.bind(this));
        this._source.on('pointerupoutside', this.onDragEnd.bind(this));
        this._source.on('pointermove', this.onDrag.bind(this));
        this._source.interactive = true;
        this._source.buttonMode = true;
        this._drag_started = false;
        this.isStopped = true;
    }

    protected turnOffScrollByTouch(): void {
        this._source.off('pointerdown', this.onDragStart.bind(this));
        this._source.off('pointerup', this.onDragEnd.bind(this));
        this._source.off('pointerupoutside', this.onDragEnd.bind(this));
        this._source.off('pointermove', this.onDrag.bind(this));
        this._source.interactive = false;
        this._source.buttonMode = false;
    }

    public turnOffScroll(useDefaultScrollPosition: boolean = false): void {
        if (DeviceInfoService.isDesktop) {
            this.dispatcher.removeListener(VerticalScrollEvents.ON_WHEEL_DELTA, this.scrollWheel);
            if (this._useSlider) {
                this.scrollBar.slider.off('pointerdown', this.onDragStart.bind(this));
                this.scrollBar.slider.off('pointerup', this.onDragEnd.bind(this));
                this.scrollBar.slider.off('pointerupoutside', this.onDragEnd.bind(this));
                this.scrollBar.slider.off('pointermove', this.onDrag.bind(this));
            }
            if (this.useScrollByTouch) {
                this.turnOffScrollByTouch();
            }
        } else {
            this.turnOffScrollByTouch();
        }

        if (useDefaultScrollPosition) {
            this._source.y = 0;
        }

        EnterFrameManager.instance.removeListener(this);
    }

    protected scrollWheel(obj: any): void {
        if (!obj) {
            return;
        }
        let source: Container = this._source;
        if (this._useSlider) {
            source = this.scrollBar.slider;
        }
        let newY: number;
        newY = source.y + obj.delta;
        if (this._useSlider) {
            let speed: number = this._source.height / this._sliderSpeed;
            if (obj.delta > 0) {
                speed = -speed
            }
            newY = source.y + speed;
            source.y = newY;
            if (source.y < 0) {
                source.y = 0
            } else if (source.y > this.scrollBar.background.height - source.height) {
                source.y = this.scrollBar.background.height - source.height;
            }
            this.updateSourcePosition(source.y);
        } else {
            if (newY < this.endDownPoint) {
                newY = this.endDownPoint
            } else if (newY > this.endUpPoint) {
                newY = this.endUpPoint
            }
            this.updateSourcePosition(newY);
        }


    }

    protected onDragStart(e): void {
        if (this._drag_started) {
            return;
        }

        this.touchStartTime = new Date().getTime();
        EnterFrameManager.instance.removeListener(this);
        let source: Container = this._source;
        if (this._useSlider) {
            source = this.scrollBar.slider;
        }
        this.lastPositionY = source.y;
        this._drag_started = true;
        this.isFirstDragStartCall = true;
        this.drag_y = e.data.global.y;

    }

    protected onDrag(e): void {
        if (!this.isStopped || !this._drag_started) {
            return;
        }
        let source: Container = this._source;
        if (this._useSlider) {
            source = this.scrollBar.slider;
        }
        const newY = (e.data.global.y - this.drag_y) / source.worldTransform.a;
        source.y = this.lastPositionY + newY;


        // add sensitive 10px , to allow small movement
        if (Math.abs(newY) > 10 && this.isFirstDragStartCall) {
            this.onDragStartDelegate && this.onDragStartDelegate();
            this.isFirstDragStartCall = false;
        }

        if (this._useSlider) {
            if (source.y < 0) {
                source.y = 0
            } else if (source.y > this.scrollBar.background.height - source.height) {
                source.y = this.scrollBar.background.height - source.height;
            }
            this.updateSourcePosition(source.y);
        }
    }

    protected onDragEnd(e): void {
        this._drag_started = false;
        this.isStopped = false;
        this.onDragEndDelegate && this.onDragEndDelegate();
        let source: Container = this._source;
        if (this._useSlider) {
            source = this.scrollBar.slider;
        }
        if (source.y < this.endDownPoint) {
            this.endScrollPages(this.endDownPoint);
            return;
        }
        if (source.y > this.endUpPoint) {
            this.endScrollPages(this.endUpPoint);
            return;
        }
        let isSwipe: boolean = false;

        const swipeTime = Date.now() - this.touchStartTime;
        if (swipeTime < this.MIN_SWIPE_TIME) {
            isSwipe = true;
        }

        if (!isSwipe) {
            this.isStopped = true;
            this.lastPositionY = source.y;
            return;
        }
        const newY = (e.data.global.y - this.drag_y) / this._source.worldTransform.a;
        this.currentStep = Math.abs(this.lastPositionY - source.y) * this.STEP_MULTIPLIER;
        if (newY < 0) {
            this.isScrollingUp = false;

        } else {
            this.isScrollingUp = true;

        }
        this.isStopped = true;
        EnterFrameManager.instance.addListener(this);
    }

    private endScrollPages(endPoint: number): void {
        if (this._useSlider) {
            this.isStopped = true;
            return;
        }
        this.tween && this.tween.kill();
        this.tween = TweenLite.to(this._source, this.END_SCROLL_DURATION, {
            y: endPoint,
            onComplete: () => {
                this.lastPositionY = this._source.y;
                this.isStopped = true;
            }
        });
    }

    onEnterFrame(deltaTime: number): void {
        let value: number = this.onUpdate();
        if (this.isScrollingUp) {
            this.updateScrollingUP(value);
        } else {
            this.updateScrollingDown(value);
        }
        this.lastPositionY = this._source.y;
        if (value === 0) {
            EnterFrameManager.instance.removeListener(this);
        }

    }

    private updateScrollingDown(value: number): void {
        this._source.emit(VerticalScrollEvents.DRAG, value);
        this._source.y -= value;
        if (this._source.y < this.endDownPoint) {
            EnterFrameManager.instance.removeListener(this);
            this.endScrollPages(this.endDownPoint);
            return;
        }
    }

    private updateScrollingUP(value: number): void {
        this._source.emit(VerticalScrollEvents.DRAG, -value);
        this._source.y += value;
        if (this._source.y > this.endUpPoint) {
            EnterFrameManager.instance.removeListener(this);
            this.endScrollPages(this.endUpPoint);
            return;
        }
    }

    private onUpdate(): number {
        this.currentStep -= this.STEP_UPDATE;
        if (this.currentStep <= 0) {
            this.currentStep = 0;
        }
        return this.currentStep;
    }

    private drawRectangle(width: number, height: number): PIXI.Graphics {
        this._width = this._source.width;
        this._height = this._source.height;
        if (width) {
            this._width = width;
        }
        if (height) {
            this._height = height
        }
        let rect = new PIXI.Graphics();
        rect.beginFill(0x00ff00);
        rect.drawRect(0, 0, this._width, this._height);
        rect.endFill();
        rect.alpha = 0;
        rect.interactive = true;
        return rect;
    }

    private updateSourcePosition(value: number) {
        if (this._tween) {
            this._tween.kill();
        }
        let result: number;
        if (this._useSlider) {
            let percent: number = (-value / (this.scrollBar.background.height - this.scrollBar.slider.height)) * 100;
            result = ((((Math.abs(this.endDownPoint))) * percent) / 100) + this.endUpPoint;
        } else {
            result = value
        }

        this._tween = TweenLite.to(this._source, this._defaultScrollDuration, {
            y: result,
            onComplete: () => {
                this._tween.kill();
            }
        })
    }
}
