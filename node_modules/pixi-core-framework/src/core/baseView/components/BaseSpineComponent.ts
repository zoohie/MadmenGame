import 'pixi-spine/bin/pixi-spine'
import SkeletonData = PIXI.spine.core.SkeletonData;
import {EnterFrameManager, IFrameListener} from "../../engine/renderer/EnterFrameManager";
import {TextureHolder} from "../../utils/layouts/TextureHolder";
import {SpineFactory} from "../factories/SpineFactory";
import Event = PIXI.spine.core.Event;
import {BaseViewComponent} from "./BaseViewComponent";
import TextureAtlas = PIXI.spine.core.TextureAtlas;
import {IBaseSpineConfig} from "../interfaces/IBaseSpineConfig";

export class BaseSpineComponent extends BaseViewComponent implements PIXI.spine.core.AnimationStateListener2, IFrameListener {
    get isActive(): boolean {
        return this._isActive;
    }

    protected _sourceData: IBaseSpineConfig;
    protected _skeletonData: PIXI.spine.core.SkeletonData;
    protected initIsComplete: boolean = false;
    protected _clip: PIXI.spine.Spine;
    protected onCompleteCallback: Function;
    protected _isActive: boolean = false;
    protected _listeners: Object = {};
    protected isOnPause: boolean;

    public init(): void {
        if (this.initIsComplete) {
            return;
        }
        this._skeletonData = this.createSkeletonData();
        this.createSpineMovie(this._skeletonData);
        this.initIsComplete = true;
    }

    protected createSkeletonData(): SkeletonData {
        const textures = TextureHolder.getTextureMap(SpineFactory.getInstance().getSkeletonData(this.layoutID), PIXI.utils.TextureCache);
        const atlas: TextureAtlas = new PIXI.spine.core.TextureAtlas(null, null, null);
        atlas.addTextureHash(textures, true);
        const atlasLoader = new PIXI.spine.core.AtlasAttachmentLoader(atlas);
        const jsonParser = new PIXI.spine.core.SkeletonJson(atlasLoader);
        const data: SkeletonData = jsonParser.readSkeletonData(SpineFactory.getInstance().getSkeletonData(this.layoutID));
        return data;
    }

    public createSpineMovie(data: SkeletonData): void {
        if (!data) {
            data = this.createSkeletonData();
        }
        this._clip = new PIXI.spine.Spine(data);
        this._clip.autoUpdate = false;
    }

    public onEnterFrame(deltaTime: number): void {
        if (this._clip && this._clip.skeleton) {
            this._clip.update(deltaTime);
            this.isOnPause = false;
            if (!this.parent) {
                this.removeClip();
            }
        }
    }

    public removeClip(): void {
        if (this._clip.state) {
            this._clip.state.removeListener(this);
        }

        // set timeout cause of PIXI Spine trouble. At first it updates it's state (and dispatch event that clip is ended) then
        // works with it's skeleton.
        // So we should destroy Spine after it finishes work with skeleton but before next tick
        setTimeout(() => {
            if (this._clip.skeleton) {
                this._clip.destroy();
            }
        }, 1);
        this._isActive = false;
        this.removeChildren();

        EnterFrameManager.instance.removeListener(this);
    }


    public playAnimation(name: string, isLoop: boolean, callback?: Function): void {
        if (!this._isActive) {
            this.activateAnimation();
        }
        this.onCompleteCallback = null;
        if (callback) {
            this.onCompleteCallback = callback;
        }
        this._clip.skeleton.setToSetupPose();
        this._clip.state.setAnimation(0, name, isLoop);
        this._clip.update(0);
    }

    public pause(): void {
        this.isOnPause = true;
        EnterFrameManager.instance.removeListener(this);
        this._isActive = false;
        this._clip.autoUpdate = false;
    }

    public resume(): void {
        this._isActive = true;
        if (this.isOnPause) {
            this.isOnPause = false;
            EnterFrameManager.instance.addListener(this);
        }

        this._clip.autoUpdate = true;
    }

    public addSpineEventListener(event: string, callback: Function): void {
        this._listeners[event] = callback;
    }

    public removeSpineEventListener(event: string): void {
        delete this._listeners[event];
    }

    public removeCompleteCollback(): void {
        this.onCompleteCallback = null;
    }

    public cheaterSetVisibility(value: boolean) {
        if (this._isActive) {
            this._clip.visible = value;
        }
    }

    protected activateAnimation() {
        this._isActive = true;
        this._clip.state.addListener(this);
        EnterFrameManager.instance.addListener(this);
        this._clip.state.onEvent = (i: number, event: Event) => {
            if (this._listeners[event.stringValue]) {
                this._listeners[event.stringValue]();
            }
        };
        this.addChild(this._clip);
    }

    start(entry: PIXI.spine.core.TrackEntry): void {
    }

    interrupt(entry: PIXI.spine.core.TrackEntry): void {
    }

    end(entry: PIXI.spine.core.TrackEntry): void {
    }

    dispose(entry: PIXI.spine.core.TrackEntry): void {
    }

    complete(entry: PIXI.spine.core.TrackEntry): void {
        if (this.onCompleteCallback) {
            this.onCompleteCallback();
        }
    }

    get skeletonData(): PIXI.spine.core.SkeletonData {
        return this._skeletonData;
    }

    get clip(): PIXI.spine.Spine {
        return this._clip;
    }

    event(entry: PIXI.spine.core.TrackEntry, event: PIXI.spine.core.Event): void {
    }

    onAdded(): void {
        throw new Error("Method not implemented.");
    }

    destroy(): void {
        throw new Error("Method not implemented.");
    }

    get sourceData(): IBaseSpineConfig {
        return this._sourceData;
    }

}
