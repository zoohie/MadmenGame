import {SlotEventDispatcher} from "../eventDispatcher/SlotEventDispatcher";
import {getDispatcher} from "../createInstance";
import {BaseAction} from "./BaseAction";
import {AppLogger} from "../../utils/logger/AppLogger";
import {AppLoggerMessageType} from "../../utils/logger/AppLoggerMessageType";

export abstract class BaseState {
    protected dispatcher: SlotEventDispatcher;
    protected actions: BaseAction[] = [];
    protected executedQueue: BaseAction[] = [];
    protected shouldSkip: boolean = false;
    protected isActive: boolean = false;
    protected mainResolve: Function;
    protected currentAction: BaseAction;

    constructor(protected _id: string, protected permittedStates: string[]) {
        this.dispatcher = getDispatcher(this);
        this.actions = this.addActions();
    }

    /**
     * This method is called just after FSM switches to this state
     */
    public start(): Promise<string> {
        this.isActive = true;
        return new Promise<string>(resolve => {
            this.execute().then(() => {
                this.isActive = false;
                this.shouldSkip = false;
                const nextState: string = this.getNextState();
                if (this.permittedStates.indexOf(nextState) !== -1) {
                    resolve(nextState);
                } else {
                    AppLogger.log(`you can't switch to  ${nextState} from  ${this.id}`, AppLoggerMessageType.ERROR)
                }

            })
        });
    }

    /**
     * Fill states with actions.
     * Use Serial and Parallel actions to wrap your actions.
     * Example:
     * return[
     *    createInstance(SerialAction, [
     *      createInstance(LoadConfigAction),
     *      createInstance(InitAppAction),
     *      createInstance(LoadAssetPreloadAction),
     *      createInstance(LoadSoundPreloadAction),
     *      createInstance(SendInitServerRequestAction),
     *      createInstance(LoadAssetInitAction),
     *      createInstance(LoadSoundInitAction),
     *      createInstance(LoadAssetLazyAction),
     *      createInstance(LoadSoundLazyAction)
     *  ]
     * )
     * ]
     */
    public abstract addActions(): BaseAction[];

    /**
     * Describe logic for switching to next state.
     *
     */
    public  abstract getNextState(): string;

    /**
     * return state id
     */
    public get id(): string {
        return this._id;
    }

    public skip(): void {
        this.shouldSkip = true;
        this.currentAction.skip();
    }

    public onEnd(): void {

    }

    protected async execute(): Promise<void> {
        if (this.isSkipped()) {
            return Promise.resolve();
        } else {
            return new Promise<void>( resolve => {
                this.executedQueue = this.actions.concat();
                this.executeActionFromQueue();
                this.mainResolve = resolve;
            });
        }
    }

    protected executeActionFromQueue(): void {
        if (this.executedQueue.length === 0 || this.shouldSkip) {
            this.mainResolve();
            return;
        }
        this.currentAction = this.executedQueue.shift();
        this.currentAction.execute().then(() => {
            this.executeActionFromQueue()
        });
    }

    protected isSkipped(): boolean {
        return false;
    }

}
