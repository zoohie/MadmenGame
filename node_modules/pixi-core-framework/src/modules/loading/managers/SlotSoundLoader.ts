import {LoaderModel, LoadEvents, SoundLoader} from "general-framework";
import {ISoundsGroup} from "../../sound/interface/ISoundsLoader";
import {Sound} from "../../sound/Sound";
import {CoreSoundEvents} from "../../sound/events/CoreSoundEvents";

export class SlotSoundLoader extends SoundLoader {

    protected loadedMap: string[] = [];

    protected loadLazySounds(group: ISoundsGroup): void {
        if (this.loadedMap.indexOf(group.id) !== -1) {
            this.checkNextLazyAsset();
            return;
        }
        let sound = new Sound({
            src: [group.url],
        });
        sound.id = group.id;
        sound.on("load", () => {
            this.dispatcher.dispatch(LoadEvents.LOAD_PROGRESS, LoaderModel.currentGroupSize(this.currentPriorityID));
            this.dispatcher.dispatch(CoreSoundEvents.MAP_SOUND, sound);
            this.loadedMap.push(sound.id);
            this.checkNextLazyAsset();
        });
    }

    protected loadQueue(soundsData: ISoundsGroup[]): Promise<any> {
        return new Promise<any>((resolve) => {
            this.mainInitialResolve = resolve;

            let count: number = 0;
            soundsData.map((item) => {
                let sound = new Sound({
                    src: [item.url],
                });
                sound.id = item.id;
                sound.on("load", () => {
                    count += 1;
                    this.dispatcher.dispatch(LoadEvents.LOAD_PROGRESS, LoaderModel.currentGroupSize(this.currentPriorityID));
                    this.dispatcher.dispatch(CoreSoundEvents.MAP_SOUND, sound);
                    this.loadedMap.push(sound.id);
                    if (count >= soundsData.length - 1) {
                        this.mainInitialResolve();
                    }
                });
            });

        });
    }
}
