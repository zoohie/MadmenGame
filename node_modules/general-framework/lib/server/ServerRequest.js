import { AppLogger } from '../logger/AppLogger';
import { GameInfo } from '../GameInfo';
import { EventDispatcher } from "../EventDispatcher";
import { ErrorServerModel } from "../modalPopup/models/ErrorServerModel";
import { ModalPopupUtil } from "../modalPopup/util/ModalPopupUtil";
import { ModalPopupEvents } from "../modalPopup/events/ModalPopupEvents";
import { LocalUtil } from "../localization/LocalUtil";
import { AppLoggerMessageType } from '../logger/AppLoggerMessageType';
import { CoreEvents } from "../CoreEvents";
import { ServerConstatnts } from "./contsants/ServerConstatnts";
import { CommonInitServerResponse } from "./controllers/CommonInitServerResponse";
import { addFetchTimestamp } from "../utils/addFetchTimestamp";
import { Socket } from "../socket/Socket";
import { SocketEvents } from '../socket/SocketEvents';
import { DeviceInfoService } from "../DeviceInfoService";
// Overwrite the native XHR and fetch method
// const originFetch = JSON.parse(JSON.stringify(window.fetch));
const originFetch = Object.freeze(window.fetch);
(() => {
    if (window.fetch) {
        const constantMock = window.fetch;
        window.fetch = function () {
            const [url, rest] = arguments;
            return constantMock.apply(this, [addFetchTimestamp(url), rest]);
        };
    }
    const open = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function () {
        const [arg, url, rest] = arguments;
        open.apply(this, [arg, addFetchTimestamp(url), rest]);
    };
})();
export class ServerRequest {
    /**
     * Create server reuest instance, incapsulating technical aspects
     * @param type ('init', 'spin', etc. Depends on server API)
     * @param prefix<string>
     * @param options
     */
    constructor(type, prefix = 'game', options = {}) {
        this.dispatcher = EventDispatcher.getInstance();
        this.cookieRow = ['testCmaMessagesAction', 'testCmaMessages'];
        /**
         * Socket
         * */
        this.socket = undefined;
        this.url = `${GameInfo.url}/${GameInfo.title}/${prefix}/${type}`;
        this.inProgress = false;
        this.currentRequestType = type;
        this.isNotPopup = options.isNotPopup || false;
        ServerRequest.MAX_REPEATS = options.maxRepeats || 3;
    }
    static addIgnoreCode(code) {
        ServerRequest.ignoreCode.push(code);
    }
    /**
     * This is a common method to fetch responses from server.
     * We have 3 possibilities to fetch with timeout 20 sec
     * @param body optional post parameters (Depends on server API)
     * @param params optional getParams to add in request
     * @param method
     */
    fetch(body = {}, params = {}, method = 'post') {
        if (this.inProgress) {
            AppLogger.log('The same request is in progress', AppLoggerMessageType.ERROR);
            return Promise.reject({
                inProgress: true
            });
        }
        this.counter = 0;
        this.inProgress = true;
        this.getParams = this.stringifyJSON(Object.assign(params, { platform_token: GameInfo.token }));
        this.fetchParams = {
            method: method,
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: this.stringifyJSON(body)
        };
        return new Promise((resolve, reject) => {
            this.doNetworkCall(resolve, reject);
        });
    }
    /**
     * Encoding object into url format
     * @param obj object to encode as url params
     */
    stringifyJSON(obj) {
        return Object.keys(obj)
            .map((x) => `${encodeURIComponent(x)}=${encodeURIComponent(obj[x])}`)
            .join('&');
    }
    /**
     * Method performs actual request to server
     * @param resolve external request resolve handler
     * @param reject external request reject handler
     */
    doNetworkCall(resolve, reject) {
        originFetch(`${this.url}?${this.getParams}`, this.fetchParams)
            .then((response) => {
            this.innerResolve(response, resolve, reject);
        }, (error) => {
            this.innerReject(error, resolve, reject);
        });
    }
    /**
     * Handler for successfull request
     * @param response data from server
     * @param resolve external request resolve handler
     * @param reject external request reject handler
     */
    innerResolve(response, resolve, reject) {
        this.fetchFinally();
        response.json()
            .then((data = { data: { gameParams: {} } }) => {
            if (response.ok) {
                if (this.currentRequestType === ServerConstatnts.INIT) {
                    CommonInitServerResponse.parseResponse(data);
                    const { gameParams } = data.data;
                    if (gameParams.socketPath && this.socket === undefined) {
                        this.socket = new Socket(gameParams.socketPath, gameParams['session.heartbeatRequestInterval']);
                        this.socket.onopen = this.onSocketOpened.bind(this, gameParams.socketChannel);
                    }
                    DeviceInfoService.addMobileDevTools(gameParams['front.settings'] && gameParams['front.settings'].showMobileDevTools);
                }
                if (data.messages) {
                    EventDispatcher.getInstance().once(ModalPopupEvents.CUSTOM_ALL_MESSAGES_SHOW_COMPLETE, () => {
                        EventDispatcher.getInstance().dispatch(CoreEvents.ON_SERVER_RESPONSE_RECEIVED, data);
                        resolve(data);
                    });
                    EventDispatcher.getInstance().dispatch(ModalPopupEvents.CUSTOM_SHOW_ALL_MESSAGES, data.messages);
                }
                else {
                    EventDispatcher.getInstance().dispatch(CoreEvents.ON_SERVER_RESPONSE_RECEIVED, data);
                    resolve(data);
                }
            }
            else {
                this.checkServerErrorMessages(data);
                reject(data);
            }
        })
            .catch((error) => {
            this.innerReject(error, resolve, reject);
        });
    }
    /**
     * Handler for failed request
     * @param error data regarding failure
     * @param resolve external request resolve handler
     * @param reject external request reject handler
     */
    innerReject(error, resolve, reject) {
        this.counter++;
        if (error.code !== undefined) {
            this.fetchFinally();
            this.checkServerErrorMessages(error);
            reject(error);
        }
        else if (this.counter < ServerRequest.MAX_REPEATS) {
            this.timeoutId = window.setTimeout(() => {
                this.doNetworkCall(resolve, reject);
            }, ServerRequest.SERVER_TIMEOUT);
        }
        else {
            this.showTimeoutError(reject);
        }
    }
    /**
     * Finilizing action after request is complete
     */
    fetchFinally() {
        clearTimeout(this.timeoutId);
        this.inProgress = false;
    }
    checkServerErrorMessages(error) {
        if (this.isNotPopup)
            return;
        const errorServerModel = new ErrorServerModel();
        if (error) {
            errorServerModel.parseResponse(error);
        }
        if (errorServerModel.status === "error") {
            const data = ModalPopupUtil.getModalPopupData(errorServerModel.code, errorServerModel.messageHeader, errorServerModel.messageBody);
            if (ServerRequest.ignoreCode.indexOf(errorServerModel.code) >= 0) {
                this.dispatcher.dispatch(ModalPopupEvents.IGNORE_MODEL_POPUP, { code: errorServerModel.code, data });
            }
            else {
                data.buttons = [{
                        class: 'warning',
                        text: LocalUtil.text("RELOAD") || 'reload',
                        callback: () => location.reload()
                    }];
                this.dispatcher.dispatch(ModalPopupEvents.SHOW_MODAL_POPUP, data, false);
            }
        }
    }
    showTimeoutError(reject) {
        if (this.isNotPopup) {
            this.fetchFinally();
            return reject({ errors: [{ code: 408, message: "SERVER_TIMEOUT" }] });
        }
        const data = ModalPopupUtil.getModalPopupData("", LocalUtil.text("SERVER_TIMEOUT"), LocalUtil.text("SERVER_TIMEOUT body"));
        data.buttons = [{
                class: 'warning',
                text: LocalUtil.text("RELOAD") || 'reload',
                callback: () => location.reload()
            }];
        this.dispatcher.dispatch(ModalPopupEvents.SHOW_MODAL_POPUP, data);
    }
    onSocketOpened(socketChannel) {
        this.socket.subscribeChannel(socketChannel, (index, event, data) => {
            if (event == "updateBalance") {
                this.dispatcher.dispatch(SocketEvents.ON_UPDATE_BALANCE, data.balance, false);
            }
        });
    }
}
ServerRequest.SERVER_TIMEOUT = 10000;
ServerRequest.ignoreCode = [];
//# sourceMappingURL=ServerRequest.js.map