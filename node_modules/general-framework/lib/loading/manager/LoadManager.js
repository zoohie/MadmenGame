import { ConfigLoader } from "../loaders/ConfigLoader";
import { AssetsLoader } from "../loaders/AssetsLoader";
import { SoundLoader } from "../loaders/SoundLoader";
import { LoadEvents } from "../events/LoadEvents";
import { BitmapFontsLoader } from "../loaders/BitmapFontsLoader";
import { LoaderModel } from "../model/LoaderModel";
import { EventDispatcher } from "../../EventDispatcher";
import { LoaderConstants } from "../constants/LoaderConstants";
import { GameInfo } from "../../GameInfo";
import * as FontFaceObserver from "fontfaceobserver";
import { HtmlPreloaderController } from '../controllers/HtmlPreloaderController';
import { AdditionalInfoController } from "../../additionalOperatorInformation/AdditionalInfoController";
export class LoadManager {
    constructor() {
        this.dispatcher = EventDispatcher.getInstance();
        this.configLoader = new ConfigLoader();
        this.assetsLoader = new AssetsLoader();
        this.soundLoader = new SoundLoader();
        this.bitmapFontsLoader = new BitmapFontsLoader();
        new HtmlPreloaderController();
        AdditionalInfoController.addListener();
        this.addListeners();
    }
    addListeners() {
        this.dispatcher.addListener(LoadEvents.LOAD_CONFIGS, this.loadConfigs.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_ASSETS, this.loadAssets.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_BITMAP_FONTS, this.loadBitmapFonts.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_SOUNDS, this.loadSounds.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_FONTS, this.loadFonts.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_LOCALIZATION, this.loadI18N.bind(this));
        this.dispatcher.addListener(LoadEvents.FORCE_LOAD, this.forceLoad.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_SPINE_DATA, this.loadSpineData.bind(this));
    }
    /**
     * load all configs to get all urls for loading
     * @param data
     * - key should be from LoaderConstants
     * each of them represents unique loaders type (for sound, asset, spine, bitmap font, etc)
     * - value is url for config
     */
    loadConfigs(data) {
        const loadPromises = [];
        for (let key in data) {
            let configPath = data[key];
            switch (key) {
                case LoaderConstants.LOADING_CONFIG_PATH: {
                    loadPromises.push(this.configLoader.loadAssetsConfig(configPath));
                    break;
                }
                case LoaderConstants.BITMAP_FONTS_CONFIG_PATH: {
                    loadPromises.push(this.configLoader.loadBitmapFontsConfig(configPath));
                    break;
                }
                case LoaderConstants.SOUND_CONFIG_PATH: {
                    loadPromises.push(this.configLoader.loadSoundConfig(configPath));
                    break;
                }
                case LoaderConstants.GAME_PARAMS_PATH: {
                    loadPromises.push(this.configLoader.loadGameParams(configPath));
                    break;
                }
                case LoaderConstants.VIEW_CONFIG_PATH: {
                    loadPromises.push(this.configLoader.loadViewConfig(configPath));
                    break;
                }
                case LoaderConstants.I18N_PREFIX_PATH: {
                    LoaderModel.i18nPaths = configPath;
                    break;
                }
                case LoaderConstants.SPINE_PREFIX_PATH: {
                    loadPromises.push(this.configLoader.loadSpineConfig(configPath));
                    break;
                }
            }
        }
        Promise.all(loadPromises).then(() => {
            this.dispatcher.dispatch(LoadEvents.CONFIG_LOADED);
        });
    }
    /**
     * load assets (atlases) according to its loading priority
     * @param priority
     */
    loadAssets(priority) {
        this.assetsLoader.load(priority).then(() => {
            this.dispatcher.dispatch(LoadEvents.ASSET_LOADED, priority);
        });
    }
    /**
     * load bitmap fonts according to its loading priority
     * @param priority
     */
    loadBitmapFonts(priority) {
        this.bitmapFontsLoader.load(priority).then(() => {
            this.dispatcher.dispatch(LoadEvents.BITMAP_FONTS_LOADED, priority);
        });
    }
    loadSpineData(priority = "") {
        Promise.all([
            this.configLoader.loadSpineData(LoaderModel.spineDataToLoad, priority),
        ]).then(() => {
            this.dispatcher.dispatch(LoadEvents.SPINE_DATA_LOADED);
        });
    }
    /**
     * Force loading for a concrete lazy loading group.
     *
     * @param group
     */
    forceLoad(group) {
        Promise.all([
            this.forceLoadAssets(group),
            this.forceLoadBitmaps(group),
            this.forceLoadSounds(group)
        ]).then(() => {
            this.dispatcher.dispatch(LoadEvents.FORCE_LOAD_COMPLETE);
        });
    }
    forceLoadAssets(groupName) {
        if (LoaderModel.isAssetsLoaded(groupName)) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            this.dispatcher.once(LoadEvents.ASSET_LOADED, () => {
                resolve();
            });
            this.assetsLoader.forceLoad(groupName);
        });
    }
    forceLoadBitmaps(groupName) {
        if (LoaderModel.isBitmapFontsLoaded(groupName)) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            this.dispatcher.once(LoadEvents.BITMAP_FONTS_LOADED, () => {
                resolve();
            });
            this.bitmapFontsLoader.forceLoad(groupName);
        });
    }
    forceLoadSounds(groupName) {
        if (LoaderModel.isSoundsLoaded(groupName)) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            this.dispatcher.once(LoadEvents.SOUND_LOADED, () => {
                resolve();
            });
            this.soundLoader.forceLoad(groupName);
        });
    }
    loadFonts(fonts) {
        const observers = [];
        Object.keys(fonts).forEach((family) => {
            observers.push(...fonts[family].map((variant) => new FontFaceObserver(family, variant)));
        });
        const dispatch = () => {
            this.dispatcher.dispatch(LoadEvents.FONTS_LOADED);
        };
        Promise.all(observers.map((o) => o.load(null, 10000))).then(dispatch, dispatch);
    }
    loadSounds(priority) {
        this.soundLoader.load(priority).then(() => {
            this.dispatcher.dispatch(LoadEvents.SOUND_LOADED);
        });
    }
    loadI18N() {
        const loadLocalization = (lang) => {
            this.configLoader.loadI18N(`${LoaderModel.i18nPaths}${lang}.json`).then(() => {
                this.dispatcher.dispatch(LoadEvents.LOCALIZATION_LOADED);
            }).catch(() => {
                GameInfo.lang = GameInfo.defaultLang;
                loadLocalization(GameInfo.lang);
            });
        };
        loadLocalization(GameInfo.lang);
    }
}
//# sourceMappingURL=LoadManager.js.map