import { LoaderModel } from "../model/LoaderModel";
import { AppLogger } from "../../logger/AppLogger";
import { LocalUtil } from "../../localization/LocalUtil";
import { EventDispatcher } from "../../EventDispatcher";
import { LoadEvents } from "../events/LoadEvents";
import { AppLoggerMessageType } from '../../logger/AppLoggerMessageType';
import { DeviceInfoService } from '../../DeviceInfoService';
import { GameInfo } from "../../GameInfo";
import { AdditionalInfoLocalization } from "../../additionalOperatorInformation/AdditionalInfoLocalization";
import { LoaderConstants } from "../constants/LoaderConstants";
export class ConfigLoader {
    constructor() {
        this.dispatcher = EventDispatcher.getInstance();
    }
    /**
     * Load config for view parser
     * @param data - url to download
     */
    loadViewConfig(data) {
        return new Promise((resolve) => {
            this.loadJson(data)
                .then((data) => {
                this.parseViewConfig(JSON.stringify(data.body));
            })
                .then(resolve);
        });
    }
    /**
     * load all params for game setup (depends on concrete game)
     * @param data - url to download
     */
    loadGameParams(data) {
        return new Promise((resolve) => {
            this.loadJson(data)
                .then((data) => {
                this.dispatcher.dispatch(LoadEvents.GAME_PARAMS_DATA_RECEIVED, data.body);
                resolve();
            });
        });
    }
    /**
     * load localization text file
     * @param data - url to download
     */
    loadI18N(data) {
        return new Promise((resolve, reject) => {
            this.loadJson(data)
                .then((data) => {
                LoaderModel.i18nLastUpdate = this.getDateByFormat(data.response.headers.get("Last-Modified"), GameInfo.lang);
                LocalUtil.setDictionary(data.body);
                LocalUtil.addDictionary(AdditionalInfoLocalization[GameInfo.lang]);
                resolve();
            }).catch(reject);
        });
    }
    /**
     * load config for assets loader (that describes loading priorities)
     * @param data - url to download
     */
    loadAssetsConfig(data) {
        return new Promise((resolve) => {
            this.loadJson(data)
                .then((data) => {
                this.parseAssetsConfig(JSON.stringify(data.body));
            })
                .then(resolve);
        });
    }
    /**
     * load config for bitmap fonts loader (that describes loading priorities)
     * @param data  - url to download
     */
    loadBitmapFontsConfig(data) {
        return new Promise((resolve) => {
            this.loadJson(data)
                .then((data) => {
                this.parseBitmapFontsConfig(JSON.stringify(data.body));
            })
                .then(resolve);
        });
    }
    /**
     * load config for sounds loader (that describes loading priorities)
     * @param data - url to download
     */
    loadSoundConfig(data) {
        return new Promise((resolve) => {
            this.loadJson(data)
                .then((data) => {
                this.parseSoundConfig(JSON.stringify(data.body));
            })
                .then(resolve);
        });
    }
    /**
     * load config for spine animations
     * @param data - url to download
     */
    loadSpineConfig(data) {
        return new Promise((resolve) => {
            this.loadJson(data)
                .then((data) => {
                this.parseSpineConfig(JSON.stringify(data.body));
            })
                .then(resolve);
        });
    }
    /**
     * parse spine animations
     * @param data
     * - @url to download
     * - @isCommon true as default in spine config. Used for localization if spine animation depends of language folder
     */
    loadSpineData(data, priority) {
        return Promise.all(data.map((spinePath) => {
            return new Promise((resolve) => {
                let id = spinePath.url.replace(".json", "");
                const langFolder = spinePath.isCommon ? "common" : GameInfo.lang;
                spinePath.url = "data/spine/" + langFolder + "/" + spinePath.url;
                // this.loadJson(addFetchTimestamp(spinePath.url))
                this.loadJson(spinePath.url)
                    .then((data) => {
                    this.parseSpineData(JSON.stringify(data.body), id, priority);
                    resolve();
                });
            });
        }));
    }
    /**
     * just loading concrete json file
     * @param data - url to download
     */
    loadJson(data) {
        return new Promise((resolve, reject) => {
            let rsp;
            // fetch(addFetchTimestamp(data))
            fetch(data)
                .then(response => {
                rsp = response;
                return rsp.json();
            })
                .then(jsonData => {
                resolve({ body: jsonData, response: rsp });
            })
                .catch(() => {
                reject();
                AppLogger.log("Can't load " + data, AppLoggerMessageType.ERROR);
            })
                .catch(() => {
                reject();
                AppLogger.log("Can't load " + data, AppLoggerMessageType.ERROR);
            });
        });
    }
    /**
     * parse data from assets config for assets loader (that describes loading priorities)
     * @param data - json object
     */
    parseSpineConfig(data) {
        let parseData = JSON.parse(data);
        parseData.data.forEach((value) => {
            LoaderModel.spineDataToLoad.push(value);
        });
        //   = data;
    }
    /**
     * parse data from assets config for assets loader (that describes loading priorities)
     * @param data - json object
     */
    parseAssetsConfig(data) {
        let dataParse = this.getAssetsByPlatform(JSON.parse(data));
        LoaderModel.initialAssets(dataParse);
        LoaderModel.preloadAssets(dataParse);
        LoaderModel.generalAssets(dataParse);
        LoaderModel.lazyAssets(dataParse);
    }
    /**
     * parse data from bitmap fonts config for bitmap fonts loader (that describes loading priorities)
     * @param data - json object
     */
    parseBitmapFontsConfig(data) {
        let dataParse = JSON.parse(data);
        LoaderModel.initialBitmapFonts(dataParse);
        LoaderModel.preloadBitmapFonts(dataParse);
        LoaderModel.lazyBitmapFonts(dataParse);
    }
    /**
     * parse data from sound config for sound loader (that describes loading priorities)
     * @param data - json object
     */
    parseSoundConfig(data) {
        let dataParse = JSON.parse(data);
        LoaderModel.initialSounds(dataParse);
        LoaderModel.preloadSounds(dataParse);
        LoaderModel.generalSounds(dataParse);
        LoaderModel.lazySounds(dataParse);
    }
    /**
     * dispatch data from spine config
     * spine config depends on concrete game and its parser has different realization
     * @param data
     * @param id
     */
    parseSpineData(data, id, priority) {
        let dataParse = JSON.parse(data);
        const spineConfig = {
            dataParse, id
        };
        if (priority === LoaderConstants.GENERAL_PRIORITY) {
            this.dispatcher.dispatch(LoadEvents.LOAD_PROGRESS, LoaderModel.currentGroupSize(priority));
        }
        this.dispatcher.dispatch(LoadEvents.SPINE_FACTORY_DATA_RECEIVED, spineConfig);
    }
    /**
     * dispatch data from view config
     * view config depends on concrete game and its parser has different realization
     * @param data
     */
    parseViewConfig(data) {
        this.dispatcher.dispatch(LoadEvents.VIEW_COMPONENTS_FACTORY_DATA_RECEIVED, JSON.parse(data));
    }
    getAssetsByPlatform(groups) {
        const out = {};
        for (const type in groups.groups) {
            const group = groups.groups[type];
            out[type] = [];
            group.forEach(asset => {
                if (asset.platform.indexOf(DeviceInfoService.platform) >= 0) {
                    out[type].push(asset);
                }
            });
        }
        return { groups: out };
    }
    /**
     * used to convert string data to correct Date and Time format
     */
    getDateByFormat(data, format) {
        return new Intl.DateTimeFormat(format).format(new Date(data));
    }
}
//# sourceMappingURL=ConfigLoader.js.map