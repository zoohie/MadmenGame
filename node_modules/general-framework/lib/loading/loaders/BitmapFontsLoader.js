import { LoaderConstants } from "../constants/LoaderConstants";
import { AppLogger } from "../../logger/AppLogger";
import { LoaderModel } from "../model/LoaderModel";
import { LoadEvents } from "../events/LoadEvents";
import { EventDispatcher } from "../../EventDispatcher";
import { GameInfo } from "../../GameInfo";
import { AppLoggerMessageType } from '../../logger/AppLoggerMessageType';
export class BitmapFontsLoader {
    constructor() {
        this.lazyQueue = [];
        this.dispatcher = EventDispatcher.getInstance();
    }
    /**
     * start load bitmap fonts by its priority
     * @param priority - one from the list [LoaderConstants.PRELOAD_PRIORITY, LoaderConstants.INITIAL_PRIORITY, LoaderConstants.LAZY_PRIORITY]
     */
    load(priority) {
        return new Promise((loadComplete) => {
            switch (priority) {
                case LoaderConstants.PRELOAD_PRIORITY:
                    return new Promise(() => {
                        this.currentPriorityID = LoaderConstants.PRELOAD_PRIORITY;
                        if (LoaderModel.preloadBitmapFontsToLoad.length <= 0) {
                            this.dispatcher.dispatch(LoadEvents.LOADING_COMPLETE);
                            loadComplete();
                            return;
                        }
                        this.loadQueue(LoaderModel.preloadBitmapFontsToLoad)
                            .then(() => {
                            AppLogger.log("ALL " + LoaderConstants.PRELOAD_PRIORITY + " bitmap fonts loaded!", AppLoggerMessageType.SUCCESS);
                            loadComplete();
                        });
                    });
                    break;
                case LoaderConstants.INITIAL_PRIORITY:
                    return new Promise(() => {
                        this.currentPriorityID = LoaderConstants.INITIAL_PRIORITY;
                        if (LoaderModel.initialBitmapFontsToLoad.length <= 0) {
                            this.dispatcher.dispatch(LoadEvents.LOADING_COMPLETE);
                            loadComplete();
                            return;
                        }
                        this.loadQueue(LoaderModel.initialBitmapFontsToLoad)
                            .then(() => {
                            AppLogger.log("ALL " + LoaderConstants.INITIAL_PRIORITY + " bitmap fonts loaded!", AppLoggerMessageType.SUCCESS);
                            loadComplete();
                        });
                    });
                    break;
                case LoaderConstants.LAZY_PRIORITY:
                    this.currentPriorityID = LoaderConstants.LAZY_PRIORITY;
                    if (LoaderModel.lazyBitmapFontsToLoad.length <= 0) {
                        this.dispatcher.dispatch(LoadEvents.LOADING_COMPLETE);
                        loadComplete();
                        return;
                    }
                    return new Promise(() => {
                        this.loadLazyQueue(LoaderModel.lazyBitmapFontsToLoad)
                            .then(() => {
                            AppLogger.log("ALL " + LoaderConstants.LAZY_PRIORITY + " bitmap fonts loaded!", AppLoggerMessageType.SUCCESS);
                            loadComplete();
                        });
                    });
                    break;
            }
        });
    }
    /**
     *@groupId parameter for force load bitmap fonts group.
     * For example feature assets group need to be load faster then other lazy load groups
     * **/
    forceLoad(groupId) {
        if (LoaderModel.lazyBitmapFontsToLoad.length <= 0) {
            return;
        }
        if (LoaderModel.isGroupLoaded(groupId) || this.currentLazyGroup.id === this.forceGroupId) {
            return;
        }
        this.forceGroupId = groupId;
    }
    /**
     *preload and initial bitmap fonts groups loader
     * **/
    loadQueue(assets) {
        return new Promise((resolve) => {
            this.mainInitialResolve = resolve;
            this.initialQueue = assets;
            /**
             * add PIXI.loader or default browser fetch.
             * Depends on concrete realization
             */
        });
    }
    /**
     * load next bitmap font from current asset queue
     * @param initialQueue
     */
    onLoadProgress(initialQueue) {
        /**
         * add PIXI.loader or default browser fetch.
         * Depends on concrete realization
         */
    }
    /**
     *create lazy bitmap queue. It consists from groups (for example bigWin, collected etc.)
     * **/
    loadLazyQueue(assets) {
        return new Promise((resolve) => {
            this.mainLazyResolve = resolve;
            const groupsId = [];
            this.lazyQueue = [];
            assets.forEach((asset) => {
                asset.group.forEach((groupName) => {
                    if (groupsId.indexOf(groupName) === -1) {
                        groupsId.push(groupName);
                    }
                });
            });
            groupsId.forEach((groupId) => {
                this.lazyQueue.push({
                    id: groupId,
                    assets: assets.filter((asset) => {
                        return asset.group.indexOf(groupId) !== -1;
                    })
                });
            });
            this.loadLazyGroup();
        });
    }
    /**
     *load concrete lazy bitmap font group
     * **/
    loadLazyGroup() {
        if (this.lazyQueue.length > 0) {
            this.currentLazyGroup = this.lazyQueue.shift();
            LoaderModel.totalLazyGroupSize += this.currentLazyGroup.assets.length;
            this.loadLazyAsset(this.currentLazyGroup.assets.pop());
        }
        else {
            this.mainLazyResolve();
        }
    }
    loadLazyAsset(asset) {
        /**
         * add PIXI.loader or default browser fetch.
         * Depends on concrete realization
         */
    }
    /**
     * logic for lazy loading
     * check if loader has to force some lazy group
     * or just load next asset
     */
    checkNextLazyAsset() {
        if (this.forceGroupId) {
            let index = this.lazyQueue.findIndex((item) => {
                return item.id === this.forceGroupId;
            });
            if (this.currentLazyGroup.assets.length > 0) {
                this.lazyQueue.unshift(this.currentLazyGroup);
                index++;
            }
            else {
                this.onLazyGroupEnd();
            }
            this.currentLazyGroup = this.lazyQueue.splice(index, 1)[0];
            this.forceGroupId = null;
            this.loadLazyAsset(this.currentLazyGroup.assets.pop());
        }
        else {
            if (this.currentLazyGroup.assets.length > 0) {
                this.loadLazyAsset(this.currentLazyGroup.assets.pop());
            }
            else {
                this.onLazyGroupEnd();
                this.loadLazyGroup();
            }
        }
    }
    onLazyGroupEnd() {
        AppLogger.log(`bitmap font group is loaded: ${this.currentLazyGroup.id}`);
        this.dispatcher.dispatch(LoadEvents.ASSET_LOADED, this.currentLazyGroup.id);
        LoaderModel.addBitmapFontsLoadedGroup(this.currentLazyGroup.id);
        LoaderModel.addLoadedGroup(this.currentLazyGroup.id);
    }
    getPath(data) {
        // return (addFetchTimestamp("data/bitmapFonts/" + GameInfo.lang + "/" + data));
        return ("data/bitmapFonts/" + GameInfo.lang + "/" + data);
    }
    onError(error) {
        AppLogger.log(error.toString(), AppLoggerMessageType.ERROR);
    }
    loadProgressHandler() {
        this.dispatcher.dispatch(LoadEvents.LOAD_PROGRESS, LoaderModel.currentGroupSize(this.currentPriorityID));
    }
}
//# sourceMappingURL=BitmapFontsLoader.js.map