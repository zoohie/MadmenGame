var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { CoreEvents } from "../CoreEvents";
import { EventDispatcher } from "../EventDispatcher";
import { RealityCheckModel } from "./RealityCheckModel";
import { ModalPopupEvents } from "../modalPopup/events/ModalPopupEvents";
import { LocalUtil } from "../localization/LocalUtil";
import { ModalPopupConstants } from "../modalPopup/constants/ModalPopupConstants";
import { AppLogger } from "../logger/AppLogger";
/**
 * prepare and return data for reality check popup
 * @method getTimeDiff
 * @method getData
 */
export class RealityCheckData {
    /**
     * Converts the difference when user started play with current time.
     * Called on every showing popup
     * @returns {string}
     */
    static getTimeDiff(freezeTime = 0) {
        const diffTime = Date.now() - RealityCheckModel.startTime - freezeTime;
        let seconds = Math.floor((diffTime / 1000) % 60);
        let minutes = Math.floor((diffTime / (1000 * 60)) % 60);
        let hours = Math.floor((diffTime / (1000 * 60 * 60)) % 24);
        hours = (hours < 10) ? "0" + hours : hours;
        minutes = (minutes < 10) ? "0" + minutes : minutes;
        seconds = (seconds < 10) ? "0" + seconds : seconds;
        return `${hours}:${minutes}:${seconds}`;
    }
    /**
     * Brings standard data for reality check popup
     * Called on every showing popup
     * @returns {{buttons: ({callback: () => void; text: string; class: string} | {callback: () => void; text: string; class: string} | {callback: () => void; text: string; class: string})[]; header: string; body: string[]}}
     */
    // TODO: ?change message if user already played over 24 hours?
    static getData(freezeTime) {
        return __awaiter(this, void 0, void 0, function* () {
            let body = [
                LocalUtil.text("Would you like to continue?"),
                `${LocalUtil.text("You have been playing for:")} ${this.getTimeDiff(freezeTime)}`
            ];
            try {
                if (RealityCheckModel.rcInfoUrl) {
                    yield this.generateBetWinData().then((response) => {
                        body.push(response);
                    });
                }
            }
            catch (e) {
                console.log(e);
            }
            return {
                header: LocalUtil.text("The time limit"),
                body: body,
                buttons: [
                    {
                        class: ModalPopupConstants.DANGER_CLASS,
                        text: LocalUtil.text("EXIT GAME"),
                        callback: () => {
                            this.dispatcher.dispatch(CoreEvents.EXIT_GAME_PRESSED);
                            this.dispatcher.dispatch(ModalPopupEvents.HIDE_MODAL_POPUP);
                            this.game_provider_id && this.sendPostData(this.STOP);
                        }
                    },
                    {
                        class: ModalPopupConstants.PRIMARY_CLASS,
                        text: LocalUtil.text("history"),
                        callback: () => {
                            this.dispatcher.dispatch(CoreEvents.SHOW_BET_HISTORY_PRESSED);
                            this.dispatcher.dispatch(ModalPopupEvents.HIDE_MODAL_POPUP);
                            this.game_provider_id && this.sendPostData(this.HISTORY);
                        }
                    },
                    {
                        class: ModalPopupConstants.SUCCESS_CLASS,
                        text: LocalUtil.text("CONTINUE"),
                        callback: () => {
                            RealityCheckModel.isFrozen = false;
                            this.dispatcher.dispatch(CoreEvents.CONTINUE_GAME_PRESSED);
                            this.dispatcher.dispatch(ModalPopupEvents.HIDE_MODAL_POPUP);
                            this.game_provider_id && this.sendPostData(this.CONTINUE);
                        }
                    },
                ],
            };
        });
    }
    /**
     * if there is this parameter in skin_params, we send window.postMessage
     */
    static get game_provider_id() {
        return this._game_provider_id;
    }
    static set game_provider_id(value) {
        this._game_provider_id = value;
    }
    /**
     * the operator needs us to send post message to the casino site
     * for them to handle redirection / page layout change.
     */
    static sendPostData(actionID) {
        window.postMessage({
            "event": "casino-reality-check",
            "action": actionID,
            "game_provider": this._game_provider_id
        }, '*');
        AppLogger.log(`sent window.postMessage, action: ${actionID}`);
    }
    /**
     * Method returns overall bet amount during session
     */
    static generateBetWinData() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield fetch(RealityCheckModel.rcInfoUrl).then((response) => __awaiter(this, void 0, void 0, function* () {
                if (response.ok) {
                    let json = yield response.json();
                    return `${LocalUtil.text("During this time you have bet:")} ${json.currencySymbol + json.totalBet} ${LocalUtil.text("and won")} ${json.currencySymbol + json.totalWin}`;
                }
            }));
        });
    }
}
RealityCheckData.HISTORY = 'history';
RealityCheckData.STOP = 'stop';
RealityCheckData.CONTINUE = 'continue';
RealityCheckData.dispatcher = EventDispatcher.getInstance();
RealityCheckData.localKeys = {
    header: 'rcHeaderMessage',
    body: ['rcBodyMessage1', 'rcBodyMessage2'],
    buttons: ['rcExitBtn', 'rcHistoryBtn', 'rcContinueBtn'],
};
//# sourceMappingURL=RealityCheckData.js.map