import {ModalPopupVO} from "./interfaces/ModalPopupVO";
import {ModalPopupEvents} from "./events/ModalPopupEvents";

/**
 * HTML modal popup view instance.
 * @method showPopup
 * @method hidePopup
 */
export class ModalPopupView {
    /**
     * HTML element that will be used as root for popup
     */
    public popupElement: HTMLDivElement;
    public emit: Function;

    /**
     * Creating and inserting in DOM html structure with parsing existing data
     * on every colling it will be new HTML instance
     * @param {ModalPopupVO} data - object with texts and buttons to show in popup
     */
    public showPopup(data: ModalPopupVO): void {
        if (!this.popupElement) {
            // if popup not created yet
            this.popupElement = document.createElement('div');
            this.popupElement.id = 'popup'
        } else {
            // Prevent on one modal overlays on another (in unforeseen situations, e.g. when have not called method hidePopup)
            this.popupElement.innerHTML = '';
        }

        // creating of containers
        const wrapper: HTMLDivElement = document.createElement('div');
        const messages: HTMLDivElement = document.createElement('div');
        wrapper.className = 'wrapper';
        messages.className = 'messages';

        for (let key in data) {
            if (data[key]) {
                const element: HTMLElement = document.createElement('div');
                element.className = key;

                if (key === 'buttons') {
                    // creating buttons
                    data[key].forEach((btn) => {
                        const button: HTMLButtonElement = document.createElement('button');
                        button.className = btn.class;
                        button.innerText = btn.text;
                        btn.callback && button.addEventListener('click', btn.callback);
                        element.appendChild(button);
                    });
                    wrapper.appendChild(element);
                    // skip appending to message container
                    continue;
                } else if (key === 'isCloseBtnShown') {
                    // if needed add button to close popup
                    element.className = 'close-wrap';
                    const closeEl: HTMLElement = document.createElement('div');
                    closeEl.className = 'btn-close';
                    element.appendChild(closeEl);
                    element.addEventListener('click', () => {
                        this.emit(ModalPopupEvents.HIDE_MODAL_POPUP);
                    });
                } else if (key === 'body' && Array.isArray(data[key])) {
                    // section with body
                    // it can span on multiple lines
                    (data[key] as string[]).forEach((text: string) => {
                        if (text) {
                            const p: HTMLParagraphElement = document.createElement('p');
                            p.innerText = text;
                            element.appendChild(p)
                        }
                    })
                } else {
                    // section for Header message or something else (optionality)
                    element.innerText = data[key]
                }

                // insert in container every created text element
                messages.appendChild(element)
            }
        }

        // append in common container and showing in DOM
        wrapper.appendChild(messages);
        this.popupElement.appendChild(wrapper);
        this.popupElement.classList.add('active');
        document.body.appendChild(this.popupElement);
    }

    /**
     * Hiding of opened popup
     * and deleting HTML popup structure
     */
    public hidePopup(): void {
        if (this.popupElement) {
            this.popupElement.classList.remove('active');
            this.popupElement.innerHTML = '';
        }
    }
}
