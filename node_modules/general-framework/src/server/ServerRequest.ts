import {AppLogger} from '../logger/AppLogger';
import {GameInfo} from '../GameInfo';
import {EventDispatcher} from "../EventDispatcher";
import {ErrorServerModel} from "../modalPopup/models/ErrorServerModel";
import {ModalPopupUtil} from "../modalPopup/util/ModalPopupUtil";
import {ModalPopupEvents} from "../modalPopup/events/ModalPopupEvents";
import {LocalUtil} from "../localization/LocalUtil";
import {AppLoggerMessageType} from '../logger/AppLoggerMessageType';
import {ModalPopupVO} from "../modalPopup/interfaces/ModalPopupVO";
import {CoreEvents} from "../CoreEvents";
import {ServerConstatnts} from "./contsants/ServerConstatnts";
import {CommonInitServerResponse} from "./controllers/CommonInitServerResponse";
import {addFetchTimestamp} from "../utils/addFetchTimestamp";
import {Socket} from "../socket/Socket";
import { SocketEvents } from '../socket/SocketEvents';
import {DeviceInfoService} from "../DeviceInfoService";

// Overwrite the native XHR and fetch method
// const originFetch = JSON.parse(JSON.stringify(window.fetch));
const originFetch = Object.freeze(window.fetch);

(() => {
    if (window.fetch) {
        const constantMock = window.fetch;
        window.fetch = function () {
            const [url, rest] = arguments;
            return constantMock.apply(this, [addFetchTimestamp(url), rest])
        }
    }

    const open = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function () {
        const [arg, url, rest] = arguments;
        open.apply(this, [arg, addFetchTimestamp(url), rest]);
    };
})();

interface IServerRequestOptions {
    maxRepeats?: number;
    isNotPopup?: boolean;
}



export class ServerRequest {
    private dispatcher = EventDispatcher.getInstance();
    private cookieRow: string[] = ['testCmaMessagesAction', 'testCmaMessages'];

    private static readonly SERVER_TIMEOUT: number = 10000;
    private static readonly ignoreCode: string[] = [];
    private static MAX_REPEATS: number;

    public static addIgnoreCode(code) {
        ServerRequest.ignoreCode.push(code);
    }

    private inProgress: boolean;
    private timeoutId: number;
    private counter: number;

    private url: string;
    private getParams: string;
    private fetchParams: any;
    protected currentRequestType: string;
    private readonly isNotPopup: boolean;

    /**
     * Create server reuest instance, incapsulating technical aspects
     * @param type ('init', 'spin', etc. Depends on server API)
     * @param prefix<string>
     * @param options
     */
    constructor(type: string, prefix: string = 'game', options: IServerRequestOptions = {}) {
        this.url = `${GameInfo.url}/${GameInfo.title}/${prefix}/${type}`;
        this.inProgress = false;
        this.currentRequestType = type;
        this.isNotPopup = options.isNotPopup || false;
        ServerRequest.MAX_REPEATS = options.maxRepeats || 3;
    }

    /**
     * This is a common method to fetch responses from server.
     * We have 3 possibilities to fetch with timeout 20 sec
     * @param body optional post parameters (Depends on server API)
     * @param params optional getParams to add in request
     * @param method
     */
    public fetch(body: any = {}, params: any = {}, method: string = 'post'): Promise<any> {
        if (this.inProgress) {
            AppLogger.log('The same request is in progress', AppLoggerMessageType.ERROR);
            return Promise.reject({
                inProgress: true
            });
        }

        this.counter = 0;
        this.inProgress = true;
        this.getParams = this.stringifyJSON(Object.assign(params, {platform_token: GameInfo.token}));
        this.fetchParams = {
            method: method,
            headers: {'Content-Type': 'application/x-www-form-urlencoded'},
            body: this.stringifyJSON(body)
        };

        return new Promise((resolve, reject) => {
            this.doNetworkCall(resolve, reject);
        });
    }

    /**
     * Socket
     * */
    public socket = undefined;

    /**
     * Encoding object into url format
     * @param obj object to encode as url params
     */
    private stringifyJSON(obj: any): string {
        return Object.keys(obj)
            .map((x) => `${encodeURIComponent(x)}=${encodeURIComponent(obj[x])}`)
            .join('&');
    }

    /**
     * Method performs actual request to server
     * @param resolve external request resolve handler
     * @param reject external request reject handler
     */
    private doNetworkCall(resolve, reject): void {
        originFetch(`${this.url}?${this.getParams}`, this.fetchParams)
            .then((response) => {
                this.innerResolve(response, resolve, reject)
            }, (error) => {
                this.innerReject(error, resolve, reject)
            });
    }

    /**
     * Handler for successfull request
     * @param response data from server
     * @param resolve external request resolve handler
     * @param reject external request reject handler
     */
    private innerResolve(response, resolve, reject): void {
        this.fetchFinally();
        response.json()
            .then((data = {data: {gameParams: {}}}) => {
                if (response.ok) {
                    if (this.currentRequestType === ServerConstatnts.INIT) {
                        CommonInitServerResponse.parseResponse(data);

                        const { gameParams } = data.data;

                        if (gameParams.socketPath && this.socket === undefined) {
                            this.socket = new Socket(gameParams.socketPath, gameParams['session.heartbeatRequestInterval']);
                            this.socket.onopen = this.onSocketOpened.bind(this, gameParams.socketChannel);
                        }

                        DeviceInfoService.addMobileDevTools(gameParams['front.settings'] && gameParams['front.settings'].showMobileDevTools);
                    }
                    if (data.messages) {
                        EventDispatcher.getInstance().once(ModalPopupEvents.CUSTOM_ALL_MESSAGES_SHOW_COMPLETE, () => {
                            EventDispatcher.getInstance().dispatch(CoreEvents.ON_SERVER_RESPONSE_RECEIVED, data);
                            resolve(data);
                        });
                        EventDispatcher.getInstance().dispatch(ModalPopupEvents.CUSTOM_SHOW_ALL_MESSAGES, data.messages);

                    } else {
                        EventDispatcher.getInstance().dispatch(CoreEvents.ON_SERVER_RESPONSE_RECEIVED, data);
                        resolve(data);
                    }

                } else {
                    this.checkServerErrorMessages(data);
                    reject(data);
                }
            })
            .catch((error) => {
                this.innerReject(error, resolve, reject);
            });
    }

    /**
     * Handler for failed request
     * @param error data regarding failure
     * @param resolve external request resolve handler
     * @param reject external request reject handler
     */
    private innerReject(error, resolve, reject): void {
        this.counter++;
        if (error.code !== undefined) {
            this.fetchFinally();
            this.checkServerErrorMessages(error);
            reject(error);
        } else if (this.counter < ServerRequest.MAX_REPEATS) {
            this.timeoutId = window.setTimeout(() => {
                this.doNetworkCall(resolve, reject);
            }, ServerRequest.SERVER_TIMEOUT);
        } else {
            this.showTimeoutError(reject);
        }
    }

    /**
     * Finilizing action after request is complete
     */
    private fetchFinally(): void {
        clearTimeout(this.timeoutId);
        this.inProgress = false;
    }

    private checkServerErrorMessages(error?: any): void {
        if (this.isNotPopup) return;

        const errorServerModel: ErrorServerModel = new ErrorServerModel();
        if (error) {
            errorServerModel.parseResponse(error);
        }
        if (errorServerModel.status === "error") {
            const data: ModalPopupVO = ModalPopupUtil.getModalPopupData(errorServerModel.code, errorServerModel.messageHeader, errorServerModel.messageBody);
            if (ServerRequest.ignoreCode.indexOf(errorServerModel.code) >= 0) {
                this.dispatcher.dispatch(ModalPopupEvents.IGNORE_MODEL_POPUP, {code: errorServerModel.code, data});
            } else {
                data.buttons = [{
                    class: 'warning',
                    text: LocalUtil.text("RELOAD") || 'reload',
                    callback: () => location.reload()
                }];
                this.dispatcher.dispatch(ModalPopupEvents.SHOW_MODAL_POPUP, data, false);
            }
        }
    }

    private showTimeoutError(reject: any): any {
        if (this.isNotPopup) {
            this.fetchFinally();
            return reject({errors: [{code: 408, message: "SERVER_TIMEOUT"}]});
        }

        const data: ModalPopupVO = ModalPopupUtil.getModalPopupData("", LocalUtil.text("SERVER_TIMEOUT"), LocalUtil.text("SERVER_TIMEOUT body"));
        data.buttons = [{
            class: 'warning',
            text: LocalUtil.text("RELOAD") || 'reload',
            callback: () => location.reload()
        }];
        this.dispatcher.dispatch(ModalPopupEvents.SHOW_MODAL_POPUP, data);
    }

    private onSocketOpened(socketChannel: string): void {
        this.socket.subscribeChannel(socketChannel, (index: number, event: string, data: any) => {
            if(event == "updateBalance") {
                this.dispatcher.dispatch(SocketEvents.ON_UPDATE_BALANCE, data.balance, false);
            }
        } );
    }
}
