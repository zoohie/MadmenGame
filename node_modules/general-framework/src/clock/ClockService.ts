import { ClockEvents } from './ClockEvents';
import { EventDispatcher } from '../EventDispatcher';
import {AdditionalInfoController} from "../additionalOperatorInformation/AdditionalInfoController";

export class ClockService {
    private static _isLog: boolean = true;
    private static tickUp: any;
    private static dispatcher = EventDispatcher.getInstance();
    /**
     * @timeDataOptions
     * This field used to show time only or full date. Should be fill with server side and send with "ClockEvents.START_CLOCK" event.
     * Full option description at "ClockEvents.START_CLOCK" event
     */
    public static timeDataOptions = { second: "numeric", hour: "numeric", minute: "numeric"/*, timeZone: "UTC"*/ };

    /**
     * Starts clock
     * @param [timeDataParams]
     */
    public static startClock(timeDataParams?: Object): void {
        this.onTickUp();
    }

    /**
     * Checking on log status
     * @param {boolean} value
     */
    public static isLog(value: boolean): void {
        this._isLog = value;
    }
    /**
     * Stops clock
     */
    public static stopClock(): void {
        clearTimeout(this.tickUp);
        this.tickUp = null;
    }

    /**
     * Determines whether tick up on
     */
    private static onTickUp(): void {
        clearTimeout(this.tickUp);
        this.tickUp = null;
        const date = new Date();
        const currentTime: string = date.toLocaleString('en', this.timeDataOptions);
        this.dispatcher.dispatch(ClockEvents.SHOW_TIME, { currentTime }, this._isLog);
        this.tickUp = setTimeout(() => this.onTickUp(), 1000);
    }

    /**
     * @alertTimeOut()
     * This method is used to start any custom timer to dispatch incoming event.
     * @interval - time after timer stop in seconds
     * @event - event name which dispatched after timer stop
     * @repeats - number of cycles to repeat same timer
     * @loop - loop timer till application is open, if timer is loop, repeats are ignored
     */
    public static alertTimeOut(params: { interval?: number, event?: string, repeats?: number, loop?: boolean }): void {
        setTimeout(() => {
            this.dispatcher.dispatch(params.event);
            if (params.loop) {
                this.alertTimeOut(params);
                return;
            }
            if (params.repeats > 0) {
                let currentRepeats: number = params.repeats - 1;
                params.repeats = currentRepeats;
                this.alertTimeOut(params);
            }
        }, params.interval * 1000);
    }
}
