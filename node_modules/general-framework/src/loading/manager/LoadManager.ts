import {ConfigLoader} from "../loaders/ConfigLoader";
import {AssetsLoader} from "../loaders/AssetsLoader";
import {SoundLoader} from "../loaders/SoundLoader";
import {LoadEvents} from "../events/LoadEvents";
import {BitmapFontsLoader} from "../loaders/BitmapFontsLoader";
import {LoaderModel} from "../model/LoaderModel";
import {EventDispatcher} from "../../EventDispatcher";
import {LoaderConstants} from "../constants/LoaderConstants";
import {GameInfo} from "../../GameInfo";
import {IFontVariant} from '../interface/IFontVariant';
import * as FontFaceObserver from "fontfaceobserver";
import {HtmlPreloaderController} from '../controllers/HtmlPreloaderController';
import {AdditionalInfoController} from "../../additionalOperatorInformation/AdditionalInfoController";

export class LoadManager {

    protected configLoader: ConfigLoader;
    protected assetsLoader: AssetsLoader;
    protected soundLoader: SoundLoader;
    protected bitmapFontsLoader: BitmapFontsLoader;
    protected dispatcher: EventDispatcher = EventDispatcher.getInstance();

    constructor() {
        this.configLoader = new ConfigLoader();
        this.assetsLoader = new AssetsLoader();
        this.soundLoader = new SoundLoader();
        this.bitmapFontsLoader = new BitmapFontsLoader();
        new HtmlPreloaderController();
        AdditionalInfoController.addListener();
        this.addListeners();
    }

    protected addListeners() {
        this.dispatcher.addListener(LoadEvents.LOAD_CONFIGS, this.loadConfigs.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_ASSETS, this.loadAssets.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_BITMAP_FONTS, this.loadBitmapFonts.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_SOUNDS, this.loadSounds.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_FONTS, this.loadFonts.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_LOCALIZATION, this.loadI18N.bind(this));
        this.dispatcher.addListener(LoadEvents.FORCE_LOAD, this.forceLoad.bind(this));
        this.dispatcher.addListener(LoadEvents.LOAD_SPINE_DATA, this.loadSpineData.bind(this));
    }

    /**
     * load all configs to get all urls for loading
     * @param data
     * - key should be from LoaderConstants
     * each of them represents unique loaders type (for sound, asset, spine, bitmap font, etc)
     * - value is url for config
     */
    protected loadConfigs(data: { [key: string]: string }): void {
        const loadPromises: Promise<void>[] = [];
        for (let key in data) {
            let configPath: string = data[key];

            switch (key) {
                case LoaderConstants.LOADING_CONFIG_PATH: {
                    loadPromises.push(this.configLoader.loadAssetsConfig(configPath));
                    break;
                }
                case LoaderConstants.BITMAP_FONTS_CONFIG_PATH: {
                    loadPromises.push(this.configLoader.loadBitmapFontsConfig(configPath));
                    break;
                }
                case LoaderConstants.SOUND_CONFIG_PATH: {
                    loadPromises.push(this.configLoader.loadSoundConfig(configPath));
                    break;
                }
                case LoaderConstants.GAME_PARAMS_PATH: {
                    loadPromises.push(this.configLoader.loadGameParams(configPath));
                    break;
                }
                case LoaderConstants.VIEW_CONFIG_PATH: {
                    loadPromises.push(this.configLoader.loadViewConfig(configPath));
                    break;
                }
                case LoaderConstants.I18N_PREFIX_PATH: {
                    LoaderModel.i18nPaths = configPath;
                    break;
                }
                case LoaderConstants.SPINE_PREFIX_PATH: {
                    loadPromises.push(this.configLoader.loadSpineConfig(configPath));
                    break;
                }
            }
        }
        Promise.all(loadPromises).then(() => {
            this.dispatcher.dispatch(LoadEvents.CONFIG_LOADED);
        })
    }

    /**
     * load assets (atlases) according to its loading priority
     * @param priority
     */
    protected loadAssets(priority: string): void {
        this.assetsLoader.load(priority).then(() => {
            this.dispatcher.dispatch(LoadEvents.ASSET_LOADED, priority);
        })
    }

    /**
     * load bitmap fonts according to its loading priority
     * @param priority
     */
    protected loadBitmapFonts(priority: string): void {
        this.bitmapFontsLoader.load(priority).then(() => {
            this.dispatcher.dispatch(LoadEvents.BITMAP_FONTS_LOADED, priority);
        })
    }

    protected loadSpineData(priority: string = ""): void {
        Promise.all([
            this.configLoader.loadSpineData(LoaderModel.spineDataToLoad, priority),
        ]).then(() => {
            this.dispatcher.dispatch(LoadEvents.SPINE_DATA_LOADED);
        })
    }

    /**
     * Force loading for a concrete lazy loading group.
     *
     * @param group
     */
    protected forceLoad(group: string): void {
        Promise.all([
            this.forceLoadAssets(group),
            this.forceLoadBitmaps(group),
            this.forceLoadSounds(group)
        ]).then(() => {
            this.dispatcher.dispatch(LoadEvents.FORCE_LOAD_COMPLETE)
        });
    }

    protected forceLoadAssets(groupName: string): Promise<any> {
        if (LoaderModel.isAssetsLoaded(groupName)) {
            return Promise.resolve();
        }
        return new Promise<any>((resolve) => {
            this.dispatcher.once(LoadEvents.ASSET_LOADED, () => {
                resolve();
            });
            this.assetsLoader.forceLoad(groupName);
        })
    }

    protected forceLoadBitmaps(groupName: string): Promise<any> {
        if (LoaderModel.isBitmapFontsLoaded(groupName)) {
            return Promise.resolve();
        }
        return new Promise<any>((resolve) => {
            this.dispatcher.once(LoadEvents.BITMAP_FONTS_LOADED, () => {
                resolve();
            });
            this.bitmapFontsLoader.forceLoad(groupName);
        })
    }

    protected forceLoadSounds(groupName: string): Promise<any> {
        if (LoaderModel.isSoundsLoaded(groupName)) {
            return Promise.resolve();
        }
        return new Promise<any>((resolve) => {
            this.dispatcher.once(LoadEvents.SOUND_LOADED, () => {
                resolve();
            });
            this.soundLoader.forceLoad(groupName);
        })
    }

    protected loadFonts(fonts: { [key: string]: IFontVariant[] }): void {
        const observers = [];
        Object.keys(fonts).forEach((family) => {
            observers.push(...fonts[family].map(
                (variant) => new FontFaceObserver(family, variant))
            );
        });
        const dispatch = () => {
            this.dispatcher.dispatch(LoadEvents.FONTS_LOADED);
        }
        Promise.all(
            observers.map((o) => o.load(null, 10000))
        ).then(dispatch, dispatch);
    }

    protected loadSounds(priority: string): void {
        this.soundLoader.load(priority).then(() => {
            this.dispatcher.dispatch(LoadEvents.SOUND_LOADED);
        })
    }

    protected loadI18N(): void {
        const loadLocalization = (lang) => {
            this.configLoader.loadI18N(`${LoaderModel.i18nPaths}${lang}.json`).then(() => {
                this.dispatcher.dispatch(LoadEvents.LOCALIZATION_LOADED);
            }).catch(() => {
                GameInfo.lang = GameInfo.defaultLang;
                loadLocalization(GameInfo.lang);
            });
        }
        loadLocalization(GameInfo.lang);
    }
}
