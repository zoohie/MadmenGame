import {LoaderConstants} from "../constants/LoaderConstants";
import {IAssetsGroup} from "../interface/IAssetsGroup";
import {AppLogger} from "../../logger/AppLogger";
import {LoaderModel} from "../model/LoaderModel";
import {DeviceInfoService} from "../../DeviceInfoService";
import {LoadEvents} from "../events/LoadEvents";
import {EventDispatcher} from "../../EventDispatcher";
import {GameInfo} from "../../GameInfo";
import {ILazyAssetGroup} from "../interface/ILazyAssetGroup";
import {AppLoggerMessageType} from '../../logger/AppLoggerMessageType';
import {addFetchTimestamp} from "../../utils/addFetchTimestamp";

export class AssetsLoader {
    protected lazyQueue: ILazyAssetGroup[] = [];
    protected initialQueue: IAssetsGroup[];
    protected currentLazyGroup: ILazyAssetGroup;
    protected forceGroupId: string;
    protected currentProgress: number = 0;
    protected currentPriorityID: string;
    protected mainLazyResolve: Function;
    protected mainInitialResolve: Function;
    protected dispatcher: EventDispatcher = EventDispatcher.getInstance();

    /**
     * start load assets by its priority
     * @param priority - one from the list [LoaderConstants.PRELOAD_PRIORITY, LoaderConstants.INITIAL_PRIORITY, LoaderConstants.LAZY_PRIORITY]
     */
    public load(priority: string): Promise<any> {
        return new Promise<any>((loadComplete) => {
            switch (priority) {
                case LoaderConstants.GENERAL_PRIORITY:
                    return new Promise<any>(() => {
                        this.currentPriorityID = LoaderConstants.GENERAL_PRIORITY;
                        if (LoaderModel.generalAssetToLoad.length <= 0) {
                            loadComplete();
                            return;
                        }
                        this.loadQueue(LoaderModel.generalAssetToLoad, this.currentPriorityID)
                            .then(() => {
                                AppLogger.log("ALL " + LoaderConstants.GENERAL_PRIORITY + " assets loaded!", AppLoggerMessageType.SUCCESS);
                                loadComplete();
                            });
                    });
                case LoaderConstants.PRELOAD_PRIORITY:
                    return new Promise<any>(() => {
                        this.currentPriorityID = LoaderConstants.PRELOAD_PRIORITY;
                        if (LoaderModel.preloadAssetToLoad.length <= 0) {
                            loadComplete();
                            return;
                        }
                        this.loadQueue(LoaderModel.preloadAssetToLoad, this.currentPriorityID)
                            .then(() => {
                                AppLogger.log("ALL " + LoaderConstants.PRELOAD_PRIORITY + " assets loaded!", AppLoggerMessageType.SUCCESS);
                                loadComplete();
                            });
                    });
                case LoaderConstants.INITIAL_PRIORITY:
                    return new Promise<any>(() => {
                        this.currentPriorityID = LoaderConstants.INITIAL_PRIORITY;
                        if (LoaderModel.initialAssetToLoad.length <= 0) {
                            loadComplete();
                            return;
                        }
                        this.loadQueue(LoaderModel.initialAssetToLoad, this.currentPriorityID)
                            .then(() => {
                                AppLogger.log("ALL " + LoaderConstants.INITIAL_PRIORITY + " assets loaded!", AppLoggerMessageType.SUCCESS);
                                loadComplete();
                            });
                    });
                case LoaderConstants.LAZY_PRIORITY:
                    this.currentPriorityID = LoaderConstants.LAZY_PRIORITY;
                    if (LoaderModel.lazyAssetToLoad.length <= 0) {
                        loadComplete();
                        return;
                    }
                    return new Promise<any>(() => {
                        this.loadLazyQueue(LoaderModel.lazyAssetToLoad, this.currentPriorityID)
                            .then(() => {
                                AppLogger.log("ALL " + LoaderConstants.LAZY_PRIORITY + " assets loaded!", AppLoggerMessageType.SUCCESS);
                                loadComplete();
                            });
                    });
            }
        })

    }

    /**
     *@groupId parameter for force load assets group.
     * For example feature assets group need to be load faster then other lazy load groups
     * **/
    public forceLoad(groupId: string): void {
        if (LoaderModel.lazyAssetToLoad.length <= 0) {
            return;
        }
        if (LoaderModel.isGroupLoaded(groupId) || this.currentLazyGroup.id === this.forceGroupId) {
            return;
        }
        this.forceGroupId = groupId;

    }

    /**
     *preload and initial asset groups loader
     * **/
    protected loadQueue(assets: IAssetsGroup[], priority: string): Promise<any> {
        return new Promise<any>((resolve) => {
            this.mainInitialResolve = resolve;
            this.initialQueue = assets;
            this.onLoadProgress(this.initialQueue, priority);
        })
    }


    /**
     * load next asset from current asset queue
     * @param initialQueue
     */
    protected onLoadProgress(initialQueue: IAssetsGroup[], priority: string) {
        initialQueue.forEach(asset => {
            function configName() {
                const split = asset.jsonUrl.split("/");
                return split[split.length - 1];
            }

            this.currentProgress++;
            this.dispatcher.dispatch(LoadEvents.ATLAS_LOADING_STARTED, configName());
            fetch(asset.jsonUrl).then(() => this.loadProgressHandler());
        });
    }

    protected loadProgressHandler() {
        this.dispatcher.dispatch(LoadEvents.LOAD_PROGRESS, LoaderModel.currentGroupSize(this.currentPriorityID));
        if (--this.currentProgress == 0) {
            this.currentProgress = 0;
            this.mainInitialResolve();
        }
    }


    /**
     *lazy asset groups loader
     * **/
    protected loadLazyQueue(assets: IAssetsGroup[], priority: string): Promise<any> {
        return new Promise<any>((resolve) => {
            this.mainLazyResolve = resolve;
            const groupsId: string[] = [];
            this.lazyQueue = [];
            assets.forEach((asset) => {
                asset.group.forEach((groupName) => {
                    if (groupsId.indexOf(groupName) === -1) {
                        groupsId.push(groupName);
                    }
                })
            });
            groupsId.forEach((groupId: string) => {
                this.lazyQueue.push(
                    {
                        id: groupId,
                        assets: assets.filter((asset) => {
                            return asset.group.indexOf(groupId) !== -1;
                        })
                    }
                );
            });
            this.loadLazyGroup();
        })
    }

    protected loadLazyGroup(): void {
        if (this.lazyQueue.length > 0) {
            this.currentLazyGroup = this.lazyQueue.shift();
            LoaderModel.totalLazyGroupSize += this.currentLazyGroup.assets.length;
            this.loadLazyAsset(this.currentLazyGroup.assets.pop());
        } else {
            this.mainLazyResolve();
        }
    }

    protected loadLazyAsset(asset: IAssetsGroup): void {
        fetch(asset.jsonUrl).then(this.checkNextLazyAsset.bind(this));
    }

    /**
     * logic for lazy loading
     * check if loader has to force some lazy group
     * or just load next asset
     */
    protected checkNextLazyAsset(): void {
        if (this.forceGroupId) {
            let index: number = this.lazyQueue.findIndex((item) => {
                return item.id === this.forceGroupId;
            })
            if (this.currentLazyGroup.assets.length > 0) {
                this.lazyQueue.unshift(this.currentLazyGroup);
                index++;
            } else {
                this.onLazyGroupEnd();
            }

            this.currentLazyGroup = this.lazyQueue.splice(index, 1)[0];
            this.forceGroupId = null;
            this.loadLazyAsset(this.currentLazyGroup.assets.pop());
        } else {
            if (this.currentLazyGroup.assets.length > 0) {
                this.loadLazyAsset(this.currentLazyGroup.assets.pop());
            } else {
                this.onLazyGroupEnd();
                this.loadLazyGroup();
            }
        }
    }

    protected onLazyGroupEnd(): void {
        AppLogger.log(`assets group is loaded: ${this.currentLazyGroup.id}`);
        this.dispatcher.dispatch(LoadEvents.ASSET_LOADED, this.currentLazyGroup.id);
        LoaderModel.addAssetsLoadedGroup(this.currentLazyGroup.id);
        LoaderModel.addLoadedGroup(this.currentLazyGroup.id);
    }

    protected getAssetsJsonPath(data: string): string {
        let dpiPostfix = data.replace(".json", "-" + DeviceInfoService.dpi + ".json");
        // return (addFetchTimestamp("data/assets/" + GameInfo.lang + "/" + dpiPostfix));
        return ("data/assets/" + GameInfo.lang + "/" + dpiPostfix);
    }

    protected onError(error) {
        AppLogger.log(error.toString(), AppLoggerMessageType.ERROR);
    }
}
