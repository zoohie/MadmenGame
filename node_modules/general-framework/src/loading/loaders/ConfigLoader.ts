import {IAssetsToLoad} from "../interface/IAssetsToLoad";
import {ISoundsLoader} from "../interface/ISoundsLoader";
import {LoaderModel} from "../model/LoaderModel";
import {AppLogger} from "../../logger/AppLogger";
import {LocalUtil} from "../../localization/LocalUtil";
import {IBitmapFontsLoader} from "../interface/IBitmapFontsLoader";
import {EventDispatcher} from "../../EventDispatcher";
import {LoadEvents} from "../events/LoadEvents";
import {AppLoggerMessageType} from '../../logger/AppLoggerMessageType';
import {IAssetsGroup} from '../interface/IAssetsGroup';
import {DeviceInfoService} from '../../DeviceInfoService';
import {GameInfo} from "../../GameInfo";
import {ISpineConfig} from "../interface/ISpineConfig";
import {IDataJSONResponse} from "../interface/IDataJSONResponse";
import {AdditionalInfoLocalization} from "../../additionalOperatorInformation/AdditionalInfoLocalization";
import {addFetchTimestamp} from "../../utils/addFetchTimestamp";
import {LoaderConstants} from "../constants/LoaderConstants";
import {ISpineLoader} from "../interface/ISpineLoader";

export class ConfigLoader {

    protected dispatcher: EventDispatcher = EventDispatcher.getInstance();


    /**
     * Load config for view parser
     * @param data - url to download
     */
    public loadViewConfig(data: string): Promise<any> {
        return new Promise<any>((resolve) => {
            this.loadJson(data)
                .then((data: IDataJSONResponse) => {
                    this.parseViewConfig(JSON.stringify(data.body));
                })
                .then(resolve)
        })
    }

    /**
     * load all params for game setup (depends on concrete game)
     * @param data - url to download
     */
    public loadGameParams(data: any): Promise<any> {
        return new Promise<any>((resolve) => {
            this.loadJson(data)
                .then((data: IDataJSONResponse) => {
                    this.dispatcher.dispatch(LoadEvents.GAME_PARAMS_DATA_RECEIVED, data.body);
                    resolve();
                })
        })
    }

    /**
     * load localization text file
     * @param data - url to download
     */
    public loadI18N(data: string): Promise<any> {
        return new Promise<any>((resolve, reject) => {
            this.loadJson(data)
                .then((data: IDataJSONResponse) => {
                    LoaderModel.i18nLastUpdate = this.getDateByFormat(
                        data.response.headers.get("Last-Modified"),
                        GameInfo.lang
                    );
                    LocalUtil.setDictionary(data.body);
                    LocalUtil.addDictionary(AdditionalInfoLocalization[GameInfo.lang]);
                    resolve();
                }).catch(reject)
        })
    }

    /**
     * load config for assets loader (that describes loading priorities)
     * @param data - url to download
     */
    public loadAssetsConfig(data: string): Promise<any> {
        return new Promise<any>((resolve) => {
            this.loadJson(data)
                .then((data: IDataJSONResponse) => {
                    this.parseAssetsConfig(JSON.stringify(data.body));
                })
                .then(resolve);
        })
    }

    /**
     * load config for bitmap fonts loader (that describes loading priorities)
     * @param data  - url to download
     */
    public loadBitmapFontsConfig(data: string): Promise<any> {
        return new Promise<any>((resolve) => {
            this.loadJson(data)
                .then((data: IDataJSONResponse) => {
                    this.parseBitmapFontsConfig(JSON.stringify(data.body));
                })
                .then(resolve)
        })
    }

    /**
     * load config for sounds loader (that describes loading priorities)
     * @param data - url to download
     */
    public loadSoundConfig(data: string): Promise<any> {
        return new Promise<any>((resolve) => {
            this.loadJson(data)
                .then((data: IDataJSONResponse) => {
                    this.parseSoundConfig(JSON.stringify(data.body));
                })
                .then(resolve)
        })
    }

    /**
     * load config for spine animations
     * @param data - url to download
     */
    public loadSpineConfig(data: string): Promise<any> {
        return new Promise<any>((resolve) => {
            this.loadJson(data)
                .then((data: IDataJSONResponse) => {
                    this.parseSpineConfig(JSON.stringify(data.body));
                })
                .then(resolve)
        })
    }

    /**
     * parse spine animations
     * @param data
     * - @url to download
     * - @isCommon true as default in spine config. Used for localization if spine animation depends of language folder
     */
    public loadSpineData(data: ISpineLoader[], priority: string): Promise<any> {
        return Promise.all(data.map((spinePath) => {
            return new Promise<any>((resolve) => {
                let id = spinePath.url.replace(".json", "");
                const langFolder: string = spinePath.isCommon ? "common" : GameInfo.lang;
                spinePath.url = "data/spine/" + langFolder + "/" + spinePath.url;
                // this.loadJson(addFetchTimestamp(spinePath.url))
                this.loadJson(spinePath.url)
                    .then((data: IDataJSONResponse) => {
                        this.parseSpineData(JSON.stringify(data.body), id, priority);
                        resolve();
                    })
            });
        }))
    }

    /**
     * just loading concrete json file
     * @param data - url to download
     */
    protected loadJson(data: string): Promise<IDataJSONResponse> {
        return new Promise((resolve, reject) => {
                let rsp: Response;

                // fetch(addFetchTimestamp(data))
                fetch(data)
                    .then(
                        response => {
                            rsp = response;
                            return rsp.json()
                        })
                    .then(
                        jsonData => {
                            resolve({body: jsonData, response: rsp})
                        })
                    .catch(() => {
                        reject();
                        AppLogger.log("Can't load " + data, AppLoggerMessageType.ERROR);
                    })
                    .catch(() => {
                        reject();
                        AppLogger.log("Can't load " + data, AppLoggerMessageType.ERROR);
                    });
            }
        )
    }

    /**
     * parse data from assets config for assets loader (that describes loading priorities)
     * @param data - json object
     */
    protected parseSpineConfig(data: any): void {

        let parseData = JSON.parse(data);
        parseData.data.forEach((value) => {
            LoaderModel.spineDataToLoad.push(value as ISpineLoader);
        })
        //   = data;
    }

    /**
     * parse data from assets config for assets loader (that describes loading priorities)
     * @param data - json object
     */
    protected parseAssetsConfig(data: any): void {
        let dataParse: IAssetsToLoad = this.getAssetsByPlatform(JSON.parse(data));
        LoaderModel.initialAssets(dataParse);
        LoaderModel.preloadAssets(dataParse);
        LoaderModel.generalAssets(dataParse);
        LoaderModel.lazyAssets(dataParse);
    }

    /**
     * parse data from bitmap fonts config for bitmap fonts loader (that describes loading priorities)
     * @param data - json object
     */
    protected parseBitmapFontsConfig(data: any): void {
        let dataParse: IBitmapFontsLoader = JSON.parse(data);
        LoaderModel.initialBitmapFonts(dataParse);
        LoaderModel.preloadBitmapFonts(dataParse);
        LoaderModel.lazyBitmapFonts(dataParse);
    }

    /**
     * parse data from sound config for sound loader (that describes loading priorities)
     * @param data - json object
     */
    protected parseSoundConfig(data: any): void {
        let dataParse: ISoundsLoader = JSON.parse(data);
        LoaderModel.initialSounds(dataParse);
        LoaderModel.preloadSounds(dataParse);
        LoaderModel.generalSounds(dataParse);
        LoaderModel.lazySounds(dataParse);
    }

    /**
     * dispatch data from spine config
     * spine config depends on concrete game and its parser has different realization
     * @param data
     * @param id
     */
    protected parseSpineData(data: any, id: string, priority: string): void {
        let dataParse: any = JSON.parse(data);
        const spineConfig: ISpineConfig = {
            dataParse, id
        };
        if (priority === LoaderConstants.GENERAL_PRIORITY) {
            this.dispatcher.dispatch(LoadEvents.LOAD_PROGRESS, LoaderModel.currentGroupSize(priority));
        }
        this.dispatcher.dispatch(LoadEvents.SPINE_FACTORY_DATA_RECEIVED, spineConfig);
    }

    /**
     * dispatch data from view config
     * view config depends on concrete game and its parser has different realization
     * @param data
     */
    protected parseViewConfig(data: any): void {
        this.dispatcher.dispatch(LoadEvents.VIEW_COMPONENTS_FACTORY_DATA_RECEIVED, JSON.parse(data));
    }

    getAssetsByPlatform(groups: IAssetsToLoad): IAssetsToLoad {
        const out = {};
        for (const type in groups.groups) {
            const group: IAssetsGroup[] = groups.groups[type];
            out[type] = [];
            group.forEach(asset => {
                if (asset.platform.indexOf(DeviceInfoService.platform) >= 0) {
                    out[type].push(asset);
                }
            });
        }
        return {groups: out} as IAssetsToLoad;
    }

    /**
     * used to convert string data to correct Date and Time format
     */
    protected getDateByFormat(data: string, format: string): string {
        return new Intl.DateTimeFormat(format).format(new Date(data));
    }
}

