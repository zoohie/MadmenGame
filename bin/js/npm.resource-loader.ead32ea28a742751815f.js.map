{"version":3,"sources":["webpack:///../src/Loader.js","webpack:///../src/Resource.js","webpack:///../src/async.js","webpack:///../src/b64.js","webpack:///../src/index.js","webpack:///../../../src/middlewares/parsing/blob.js"],"names":["async","rgxExtractUrlHash","Loader","baseUrl","concurrency","this","progress","loading","defaultQueryString","_beforeMiddleware","_afterMiddleware","_resourcesParsing","_boundLoadResource","r","d","_loadResource","_queue","queue","pause","resources","onProgress","Signal","onError","onLoad","onStart","onComplete","i","_defaultBeforeMiddleware","length","pre","_defaultAfterMiddleware","use","add","name","url","options","cb","Array","isArray","callback","key","Error","parentResource","_prepareUrl","Resource","onAfterMiddleware","once","parent","incompleteChildren","children","isComplete","push","eachChunk","progressChunk","fn","reset","k","kill","res","_onLoadBinding","detach","isLoading","abort","load","idle","_onStart","_onComplete","chunk","_tasks","data","resume","parsedUrl","strictMode","result","protocol","path","indexOf","lastIndexOf","charAt","hash","exec","substr","resource","dequeue","_dequeue","eachSeries","next","call","_onLoad","dispatch","Math","min","error","splice","useXdr","window","XDomainRequest","XMLHttpRequest","tempAnchor","_noop","_flags","_setFlag","STATUS_FLAGS","DATA_URL","extension","_getExtension","crossOrigin","timeout","loadType","_determineLoadType","xhrType","metadata","xhr","type","TYPE","UNKNOWN","_elementTimer","_boundComplete","complete","bind","_boundOnError","_onError","_boundOnProgress","_onProgress","_boundOnTimeout","_onTimeout","_boundXhrOnError","_xhrOnError","_boundXhrOnTimeout","_xhrOnTimeout","_boundXhrOnAbort","_xhrOnAbort","_boundXhrOnLoad","_xhrOnLoad","setExtensionLoadType","extname","setExtMap","_loadTypeMap","setExtensionXhrType","_xhrTypeMap","_clearEvents","_finish","message","xdr","src","EMPTY_GIF","firstChild","removeChild","setTimeout","LOADING","_determineCrossOrigin","LOAD_TYPE","IMAGE","_loadElement","AUDIO","_loadSourceElement","VIDEO","XHR","_loadXdr","_loadXhr","_hasFlag","flag","value","clearTimeout","removeEventListener","onerror","ontimeout","onprogress","onload","COMPLETE","loadElement","Image","document","createElement","skipSource","addEventListener","Audio","navigator","isCocoonJS","mimeTypes","mimeType","appendChild","_createSource","_determineXhrType","open","XHR_RESPONSE_TYPE","JSON","DOCUMENT","responseType","TEXT","send","mime","source","event","target","nodeName","lengthComputable","loaded","total","reqType","status","statusText","text","responseText","BUFFER","parse","e","DOMParser","domparser","parseFromString","div","innerHTML","XML","response","responseURL","loc","origin","location","href","samePort","port","host","hostname","ext","isDataUrl","slashIndex","substring","queryStart","hashStart","index","toLowerCase","_getMimeFromXhrType","BLOB","DEFAULT","map","val","toString","replace","NONE","gif","png","bmp","jpg","jpeg","tif","tiff","webp","tga","svg","mp3","ogg","wav","mp4","webm","xhtml","html","htm","xml","tmx","tsx","json","txt","ttf","otf","module","exports","default","onlyOnce","callFn","apply","arguments","array","iterator","deferNext","len","err","worker","workers","q","saturated","unsaturated","buffer","empty","drain","started","paused","_insert","unshift","process","task","shift","_next","running","w","insertAtFront","item","encodeBinary","input","output","inx","bytebuffer","encodedCharIndexes","jnx","charCodeAt","require","b64","base64","blobMiddlewareFactory","Blob","Url","createObjectURL","blob","revokeObjectURL","getResponseHeader","URL","webkitURL"],"mappings":"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","file":"js/npm.resource-loader.ead32ea28a742751815f.js","sourcesContent":["import Signal from 'mini-signals';\nimport parseUri from 'parse-uri';\nimport * as async from './async';\nimport { Resource } from './Resource';\n\n// some constants\nconst MAX_PROGRESS = 100;\nconst rgxExtractUrlHash = /(#[\\w-]+)?$/;\n\n/**\n * Manages the state and loading of multiple resources to load.\n *\n * @class\n */\nexport class Loader {\n    /**\n     * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.\n     * @param {number} [concurrency=10] - The number of resources to load concurrently.\n     */\n    constructor(baseUrl = '', concurrency = 10) {\n        /**\n         * The base url for all resources loaded by this loader.\n         *\n         * @member {string}\n         */\n        this.baseUrl = baseUrl;\n\n        /**\n         * The progress percent of the loader going through the queue.\n         *\n         * @member {number}\n         */\n        this.progress = 0;\n\n        /**\n         * Loading state of the loader, true if it is currently loading resources.\n         *\n         * @member {boolean}\n         */\n        this.loading = false;\n\n        /**\n         * A querystring to append to every URL added to the loader.\n         *\n         * This should be a valid query string *without* the question-mark (`?`). The loader will\n         * also *not* escape values for you. Make sure to escape your parameters with\n         * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n         *\n         * @example\n         * const loader = new Loader();\n         *\n         * loader.defaultQueryString = 'user=me&password=secret';\n         *\n         * // This will request 'image.png?user=me&password=secret'\n         * loader.add('image.png').load();\n         *\n         * loader.reset();\n         *\n         * // This will request 'image.png?v=1&user=me&password=secret'\n         * loader.add('iamge.png?v=1').load();\n         *\n         * @member {string}\n         */\n        this.defaultQueryString = '';\n\n        /**\n         * The middleware to run before loading each resource.\n         *\n         * @private\n         * @member {function[]}\n         */\n        this._beforeMiddleware = [];\n\n        /**\n         * The middleware to run after loading each resource.\n         *\n         * @private\n         * @member {function[]}\n         */\n        this._afterMiddleware = [];\n\n        /**\n         * The tracks the resources we are currently completing parsing for.\n         *\n         * @private\n         * @member {Resource[]}\n         */\n        this._resourcesParsing = [];\n\n        /**\n         * The `_loadResource` function bound with this object context.\n         *\n         * @private\n         * @member {function}\n         * @param {Resource} r - The resource to load\n         * @param {Function} d - The dequeue function\n         * @return {undefined}\n         */\n        this._boundLoadResource = (r, d) => this._loadResource(r, d);\n\n        /**\n         * The resources waiting to be loaded.\n         *\n         * @private\n         * @member {Resource[]}\n         */\n        this._queue = async.queue(this._boundLoadResource, concurrency);\n\n        this._queue.pause();\n\n        /**\n         * All the resources for this loader keyed by name.\n         *\n         * @member {object<string, Resource>}\n         */\n        this.resources = {};\n\n        /**\n         * Dispatched once per loaded or errored resource.\n         *\n         * The callback looks like {@link Loader.OnProgressSignal}.\n         *\n         * @member {Signal<Loader.OnProgressSignal>}\n         */\n        this.onProgress = new Signal();\n\n        /**\n         * Dispatched once per errored resource.\n         *\n         * The callback looks like {@link Loader.OnErrorSignal}.\n         *\n         * @member {Signal<Loader.OnErrorSignal>}\n         */\n        this.onError = new Signal();\n\n        /**\n         * Dispatched once per loaded resource.\n         *\n         * The callback looks like {@link Loader.OnLoadSignal}.\n         *\n         * @member {Signal<Loader.OnLoadSignal>}\n         */\n        this.onLoad = new Signal();\n\n        /**\n         * Dispatched when the loader begins to process the queue.\n         *\n         * The callback looks like {@link Loader.OnStartSignal}.\n         *\n         * @member {Signal<Loader.OnStartSignal>}\n         */\n        this.onStart = new Signal();\n\n        /**\n         * Dispatched when the queued resources all load.\n         *\n         * The callback looks like {@link Loader.OnCompleteSignal}.\n         *\n         * @member {Signal<Loader.OnCompleteSignal>}\n         */\n        this.onComplete = new Signal();\n\n        // Add default before middleware\n        for (let i = 0; i < Loader._defaultBeforeMiddleware.length; ++i) {\n            this.pre(Loader._defaultBeforeMiddleware[i]);\n        }\n\n        // Add default after middleware\n        for (let i = 0; i < Loader._defaultAfterMiddleware.length; ++i) {\n            this.use(Loader._defaultAfterMiddleware[i]);\n        }\n    }\n\n    /**\n     * When the progress changes the loader and resource are disaptched.\n     *\n     * @memberof Loader\n     * @callback OnProgressSignal\n     * @param {Loader} loader - The loader the progress is advancing on.\n     * @param {Resource} resource - The resource that has completed or failed to cause the progress to advance.\n     */\n\n    /**\n     * When an error occurrs the loader and resource are disaptched.\n     *\n     * @memberof Loader\n     * @callback OnErrorSignal\n     * @param {Loader} loader - The loader the error happened in.\n     * @param {Resource} resource - The resource that caused the error.\n     */\n\n    /**\n     * When a load completes the loader and resource are disaptched.\n     *\n     * @memberof Loader\n     * @callback OnLoadSignal\n     * @param {Loader} loader - The loader that laoded the resource.\n     * @param {Resource} resource - The resource that has completed loading.\n     */\n\n    /**\n     * When the loader starts loading resources it dispatches this callback.\n     *\n     * @memberof Loader\n     * @callback OnStartSignal\n     * @param {Loader} loader - The loader that has started loading resources.\n     */\n\n    /**\n     * When the loader completes loading resources it dispatches this callback.\n     *\n     * @memberof Loader\n     * @callback OnCompleteSignal\n     * @param {Loader} loader - The loader that has finished loading resources.\n     */\n\n    /**\n     * Options for a call to `.add()`.\n     *\n     * @see Loader#add\n     *\n     * @typedef {object} IAddOptions\n     * @property {string} [name] - The name of the resource to load, if not passed the url is used.\n     * @property {string} [key] - Alias for `name`.\n     * @property {string} [url] - The url for this resource, relative to the baseUrl of this loader.\n     * @property {string|boolean} [crossOrigin] - Is this request cross-origin? Default is to\n     *      determine automatically.\n     * @property {number} [timeout=0] - A timeout in milliseconds for the load. If the load takes\n     *      longer than this time it is cancelled and the load is considered a failure. If this value is\n     *      set to `0` then there is no explicit timeout.\n     * @property {Resource.LOAD_TYPE} [loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n     *      be loaded?\n     * @property {Resource.XHR_RESPONSE_TYPE} [xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n     *      should the data being loaded be interpreted when using XHR?\n     * @property {Resource.OnCompleteSignal} [onComplete] - Callback to add an an onComplete signal istener.\n     * @property {Resource.OnCompleteSignal} [callback] - Alias for `onComplete`.\n     * @property {Resource.IMetadata} [metadata] - Extra configuration for middleware and the Resource object.\n     */\n\n    /* eslint-disable require-jsdoc,valid-jsdoc */\n    /**\n     * Adds a resource (or multiple resources) to the loader queue.\n     *\n     * This function can take a wide variety of different parameters. The only thing that is always\n     * required the url to load. All the following will work:\n     *\n     * ```js\n     * loader\n     *     // normal param syntax\n     *     .add('key', 'http://...', function () {})\n     *     .add('http://...', function () {})\n     *     .add('http://...')\n     *\n     *     // object syntax\n     *     .add({\n     *         name: 'key2',\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         name: 'key3',\n     *         url: 'http://...'\n     *         onComplete: function () {}\n     *     })\n     *     .add({\n     *         url: 'https://...',\n     *         onComplete: function () {},\n     *         crossOrigin: true\n     *     })\n     *\n     *     // you can also pass an array of objects or urls or both\n     *     .add([\n     *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n     *         { url: 'http://...', onComplete: function () {} },\n     *         'http://...'\n     *     ])\n     *\n     *     // and you can use both params and options\n     *     .add('key', 'http://...', { crossOrigin: true }, function () {})\n     *     .add('http://...', { crossOrigin: true }, function () {});\n     * ```\n     *\n     * @function\n     * @variation 1\n     * @param {string} name - The name of the resource to load.\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 2\n     * @param {string} name - The name of the resource to load.\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {IAddOptions} [options] - The options for the load.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 3\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 4\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {IAddOptions} [options] - The options for the load.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 5\n     * @param {IAddOptions} options - The options for the load. This object must contain a `url` property.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 6\n     * @param {Array<IAddOptions|string>} resources - An array of resources to load, where each is\n     *      either an object with the options or a string url. If you pass an object, it must contain a `url` property.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     */\n    add(name, url, options, cb) {\n        // special case of an array of objects or urls\n        if (Array.isArray(name)) {\n            for (let i = 0; i < name.length; ++i) {\n                this.add(name[i]);\n            }\n\n            return this;\n        }\n\n        // if an object is passed instead of params\n        if (typeof name === 'object') {\n            cb = url || name.callback || name.onComplete;\n            options = name;\n            url = name.url;\n            name = name.name || name.key || name.url;\n        }\n\n        // case where no name is passed shift all args over by one.\n        if (typeof url !== 'string') {\n            cb = options;\n            options = url;\n            url = name;\n        }\n\n        // now that we shifted make sure we have a proper url.\n        if (typeof url !== 'string') {\n            throw new Error('No url passed to add resource to loader.');\n        }\n\n        // options are optional so people might pass a function and no options\n        if (typeof options === 'function') {\n            cb = options;\n            options = null;\n        }\n\n        // if loading already you can only add resources that have a parent.\n        if (this.loading && (!options || !options.parentResource)) {\n            throw new Error('Cannot add resources while the loader is running.');\n        }\n\n        // check if resource already exists.\n        if (this.resources[name]) {\n            throw new Error(`Resource named \"${name}\" already exists.`);\n        }\n\n        // add base url if this isn't an absolute url\n        url = this._prepareUrl(url);\n\n        // create the store the resource\n        this.resources[name] = new Resource(name, url, options);\n\n        if (typeof cb === 'function') {\n            this.resources[name].onAfterMiddleware.once(cb);\n        }\n\n        // if actively loading, make sure to adjust progress chunks for that parent and its children\n        if (this.loading) {\n            const parent = options.parentResource;\n            const incompleteChildren = [];\n\n            for (let i = 0; i < parent.children.length; ++i) {\n                if (!parent.children[i].isComplete) {\n                    incompleteChildren.push(parent.children[i]);\n                }\n            }\n\n            const fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent\n            const eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child\n\n            parent.children.push(this.resources[name]);\n            parent.progressChunk = eachChunk;\n\n            for (let i = 0; i < incompleteChildren.length; ++i) {\n                incompleteChildren[i].progressChunk = eachChunk;\n            }\n\n            this.resources[name].progressChunk = eachChunk;\n        }\n\n        // add the resource to the queue\n        this._queue.push(this.resources[name]);\n\n        return this;\n    }\n    /* eslint-enable require-jsdoc,valid-jsdoc */\n\n    /**\n     * Sets up a middleware function that will run *before* the\n     * resource is loaded.\n     *\n     * @param {function} fn - The middleware function to register.\n     * @return {this} Returns itself.\n     */\n    pre(fn) {\n        this._beforeMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Sets up a middleware function that will run *after* the\n     * resource is loaded.\n     *\n     * @param {function} fn - The middleware function to register.\n     * @return {this} Returns itself.\n     */\n    use(fn) {\n        this._afterMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Resets the queue of the loader to prepare for a new load.\n     *\n     * @return {this} Returns itself.\n     */\n    reset() {\n        this.progress = 0;\n        this.loading = false;\n\n        this._queue.kill();\n        this._queue.pause();\n\n        // abort all resource loads\n        for (const k in this.resources) {\n            const res = this.resources[k];\n\n            if (res._onLoadBinding) {\n                res._onLoadBinding.detach();\n            }\n\n            if (res.isLoading) {\n                res.abort();\n            }\n        }\n\n        this.resources = {};\n\n        return this;\n    }\n\n    /**\n     * Starts loading the queued resources.\n     *\n     * @param {function} [cb] - Optional callback that will be bound to the `complete` event.\n     * @return {this} Returns itself.\n     */\n    load(cb) {\n        // register complete callback if they pass one\n        if (typeof cb === 'function') {\n            this.onComplete.once(cb);\n        }\n\n        // if the queue has already started we are done here\n        if (this.loading) {\n            return this;\n        }\n\n        if (this._queue.idle()) {\n            this._onStart();\n            this._onComplete();\n        }\n        else {\n            // distribute progress chunks\n            const numTasks = this._queue._tasks.length;\n            const chunk = MAX_PROGRESS / numTasks;\n\n            for (let i = 0; i < this._queue._tasks.length; ++i) {\n                this._queue._tasks[i].data.progressChunk = chunk;\n            }\n\n            // notify we are starting\n            this._onStart();\n\n            // start loading\n            this._queue.resume();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of resources to load concurrently.\n     *\n     * @member {number}\n     * @default 10\n     */\n    get concurrency() {\n        return this._queue.concurrency;\n    }\n    // eslint-disable-next-line require-jsdoc\n    set concurrency(concurrency) {\n        this._queue.concurrency = concurrency;\n    }\n\n    /**\n     * Prepares a url for usage based on the configuration of this object\n     *\n     * @private\n     * @param {string} url - The url to prepare.\n     * @return {string} The prepared url.\n     */\n    _prepareUrl(url) {\n        const parsedUrl = parseUri(url, { strictMode: true });\n        let result;\n\n        // absolute url, just use it as is.\n        if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {\n            result = url;\n        }\n        // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n        else if (this.baseUrl.length\n            && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1\n            && url.charAt(0) !== '/'\n        ) {\n            result = `${this.baseUrl}/${url}`;\n        }\n        else {\n            result = this.baseUrl + url;\n        }\n\n        // if we need to add a default querystring, there is a bit more work\n        if (this.defaultQueryString) {\n            const hash = rgxExtractUrlHash.exec(result)[0];\n\n            result = result.substr(0, result.length - hash.length);\n\n            if (result.indexOf('?') !== -1) {\n                result += `&${this.defaultQueryString}`;\n            }\n            else {\n                result += `?${this.defaultQueryString}`;\n            }\n\n            result += hash;\n        }\n\n        return result;\n    }\n\n    /**\n     * Loads a single resource.\n     *\n     * @private\n     * @param {Resource} resource - The resource to load.\n     * @param {function} dequeue - The function to call when we need to dequeue this item.\n     */\n    _loadResource(resource, dequeue) {\n        resource._dequeue = dequeue;\n\n        // run before middleware\n        async.eachSeries(\n            this._beforeMiddleware,\n            (fn, next) => {\n                fn.call(this, resource, () => {\n                    // if the before middleware marks the resource as complete,\n                    // break and don't process any more before middleware\n                    next(resource.isComplete ? {} : null);\n                });\n            },\n            () => {\n                if (resource.isComplete) {\n                    this._onLoad(resource);\n                }\n                else {\n                    resource._onLoadBinding = resource.onComplete.once(this._onLoad, this);\n                    resource.load();\n                }\n            },\n            true\n        );\n    }\n\n    /**\n     * Called once loading has started.\n     *\n     * @private\n     */\n    _onStart() {\n        this.progress = 0;\n        this.loading = true;\n        this.onStart.dispatch(this);\n    }\n\n    /**\n     * Called once each resource has loaded.\n     *\n     * @private\n     */\n    _onComplete() {\n        this.progress = MAX_PROGRESS;\n        this.loading = false;\n        this.onComplete.dispatch(this, this.resources);\n    }\n\n    /**\n     * Called each time a resources is loaded.\n     *\n     * @private\n     * @param {Resource} resource - The resource that was loaded\n     */\n    _onLoad(resource) {\n        resource._onLoadBinding = null;\n\n        // remove this resource from the async queue, and add it to our list of resources that are being parsed\n        this._resourcesParsing.push(resource);\n        resource._dequeue();\n\n        // run all the after middleware for this resource\n        async.eachSeries(\n            this._afterMiddleware,\n            (fn, next) => {\n                fn.call(this, resource, next);\n            },\n            () => {\n                resource.onAfterMiddleware.dispatch(resource);\n\n                this.progress = Math.min(MAX_PROGRESS, this.progress + resource.progressChunk);\n                this.onProgress.dispatch(this, resource);\n\n                if (resource.error) {\n                    this.onError.dispatch(resource.error, this, resource);\n                }\n                else {\n                    this.onLoad.dispatch(this, resource);\n                }\n\n                this._resourcesParsing.splice(this._resourcesParsing.indexOf(resource), 1);\n\n                // do completion check\n                if (this._queue.idle() && this._resourcesParsing.length === 0) {\n                    this._onComplete();\n                }\n            },\n            true\n        );\n    }\n}\n\n/**\n * A default array of middleware to run before loading each resource.\n * Each of these middlewares are added to any new Loader instances when they are created.\n *\n * @private\n * @member {function[]}\n */\nLoader._defaultBeforeMiddleware = [];\n\n/**\n * A default array of middleware to run after loading each resource.\n * Each of these middlewares are added to any new Loader instances when they are created.\n *\n * @private\n * @member {function[]}\n */\nLoader._defaultAfterMiddleware = [];\n\n/**\n * Sets up a middleware function that will run *before* the\n * resource is loaded.\n *\n * @static\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\nLoader.pre = function LoaderPreStatic(fn) {\n    Loader._defaultBeforeMiddleware.push(fn);\n\n    return Loader;\n};\n\n/**\n * Sets up a middleware function that will run *after* the\n * resource is loaded.\n *\n * @static\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\nLoader.use = function LoaderUseStatic(fn) {\n    Loader._defaultAfterMiddleware.push(fn);\n\n    return Loader;\n};\n","import parseUri from 'parse-uri';\nimport Signal from 'mini-signals';\n\n// tests if CORS is supported in XHR, if not we need to use XDR\nconst useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest())));\nlet tempAnchor = null;\n\n// some status constants\nconst STATUS_NONE = 0;\nconst STATUS_OK = 200;\nconst STATUS_EMPTY = 204;\nconst STATUS_IE_BUG_EMPTY = 1223;\nconst STATUS_TYPE_OK = 2;\n\n// noop\nfunction _noop() { /* empty */ }\n\n/**\n * Manages the state and loading of a resource and all child resources.\n *\n * @class\n */\nexport class Resource {\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n     */\n    static setExtensionLoadType(extname, loadType) {\n        setExtMap(Resource._loadTypeMap, extname, loadType);\n    }\n\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n     */\n    static setExtensionXhrType(extname, xhrType) {\n        setExtMap(Resource._xhrTypeMap, extname, xhrType);\n    }\n\n    /**\n     * @param {string} name - The name of the resource to load.\n     * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n     *      an array of sources.\n     * @param {object} [options] - The options for the load.\n     * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n     *      determine automatically.\n     * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n     *      longer than this time it is cancelled and the load is considered a failure. If this value is\n     *      set to `0` then there is no explicit timeout.\n     * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n     *      be loaded?\n     * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n     *      should the data being loaded be interpreted when using XHR?\n     * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.\n     */\n    constructor(name, url, options) {\n        if (typeof name !== 'string' || typeof url !== 'string') {\n            throw new Error('Both name and url are required for constructing a resource.');\n        }\n\n        options = options || {};\n\n        /**\n         * The state flags of this resource.\n         *\n         * @private\n         * @member {number}\n         */\n        this._flags = 0;\n\n        // set data url flag, needs to be set early for some _determineX checks to work.\n        this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n\n        /**\n         * The name of this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.name = name;\n\n        /**\n         * The url used to load this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.url = url;\n\n        /**\n         * The extension used to load this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.extension = this._getExtension();\n\n        /**\n         * The data that was loaded by the resource.\n         *\n         * @member {any}\n         */\n        this.data = null;\n\n        /**\n         * Is this request cross-origin? If unset, determined automatically.\n         *\n         * @member {string}\n         */\n        this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n\n        /**\n         * A timeout in milliseconds for the load. If the load takes longer than this time\n         * it is cancelled and the load is considered a failure. If this value is set to `0`\n         * then there is no explicit timeout.\n         *\n         * @member {number}\n         */\n        this.timeout = options.timeout || 0;\n\n        /**\n         * The method of loading to use for this resource.\n         *\n         * @member {Resource.LOAD_TYPE}\n         */\n        this.loadType = options.loadType || this._determineLoadType();\n\n        /**\n         * The type used to load the resource via XHR. If unset, determined automatically.\n         *\n         * @member {string}\n         */\n        this.xhrType = options.xhrType;\n\n        /**\n         * Extra info for middleware, and controlling specifics about how the resource loads.\n         *\n         * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n         * Meaning it will modify it as it sees fit.\n         *\n         * @member {Resource.IMetadata}\n         */\n        this.metadata = options.metadata || {};\n\n        /**\n         * The error that occurred while loading (if any).\n         *\n         * @readonly\n         * @member {Error}\n         */\n        this.error = null;\n\n        /**\n         * The XHR object that was used to load this resource. This is only set\n         * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n         *\n         * @readonly\n         * @member {XMLHttpRequest}\n         */\n        this.xhr = null;\n\n        /**\n         * The child resources this resource owns.\n         *\n         * @readonly\n         * @member {Resource[]}\n         */\n        this.children = [];\n\n        /**\n         * The resource type.\n         *\n         * @readonly\n         * @member {Resource.TYPE}\n         */\n        this.type = Resource.TYPE.UNKNOWN;\n\n        /**\n         * The progress chunk owned by this resource.\n         *\n         * @readonly\n         * @member {number}\n         */\n        this.progressChunk = 0;\n\n        /**\n         * The `dequeue` method that will be used a storage place for the async queue dequeue method\n         * used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */\n        this._dequeue = _noop;\n\n        /**\n         * Used a storage place for the on load binding used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */\n        this._onLoadBinding = null;\n\n        /**\n         * The timer for element loads to check if they timeout.\n         *\n         * @private\n         * @member {number}\n         */\n        this._elementTimer = 0;\n\n        /**\n         * The `complete` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundComplete = this.complete.bind(this);\n\n        /**\n         * The `_onError` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnError = this._onError.bind(this);\n\n        /**\n         * The `_onProgress` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnProgress = this._onProgress.bind(this);\n\n        /**\n         * The `_onTimeout` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnTimeout = this._onTimeout.bind(this);\n\n        // xhr callbacks\n        this._boundXhrOnError = this._xhrOnError.bind(this);\n        this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n\n        /**\n         * Dispatched when the resource beings to load.\n         *\n         * The callback looks like {@link Resource.OnStartSignal}.\n         *\n         * @member {Signal<Resource.OnStartSignal>}\n         */\n        this.onStart = new Signal();\n\n        /**\n         * Dispatched each time progress of this resource load updates.\n         * Not all resources types and loader systems can support this event\n         * so sometimes it may not be available. If the resource\n         * is being loaded on a modern browser, using XHR, and the remote server\n         * properly sets Content-Length headers, then this will be available.\n         *\n         * The callback looks like {@link Resource.OnProgressSignal}.\n         *\n         * @member {Signal<Resource.OnProgressSignal>}\n         */\n        this.onProgress = new Signal();\n\n        /**\n         * Dispatched once this resource has loaded, if there was an error it will\n         * be in the `error` property.\n         *\n         * The callback looks like {@link Resource.OnCompleteSignal}.\n         *\n         * @member {Signal<Resource.OnCompleteSignal>}\n         */\n        this.onComplete = new Signal();\n\n        /**\n         * Dispatched after this resource has had all the *after* middleware run on it.\n         *\n         * The callback looks like {@link Resource.OnCompleteSignal}.\n         *\n         * @member {Signal<Resource.OnCompleteSignal>}\n         */\n        this.onAfterMiddleware = new Signal();\n    }\n\n    /**\n     * When the resource starts to load.\n     *\n     * @memberof Resource\n     * @callback OnStartSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * When the resource reports loading progress.\n     *\n     * @memberof Resource\n     * @callback OnProgressSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     * @param {number} percentage - The progress of the load in the range [0, 1].\n     */\n\n    /**\n     * When the resource finishes loading.\n     *\n     * @memberof Resource\n     * @callback OnCompleteSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * @memberof Resource\n     * @typedef {object} IMetadata\n     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n     *      element to use for loading, instead of creating one.\n     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n     *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n     * @property {string|string[]} [mimeType] - The mime type to use for the source element\n     *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n     *      where each index is the mime type to use for the corresponding url index.\n     */\n\n    /**\n     * Stores whether or not this url is a data url.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isDataUrl() {\n        return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);\n    }\n\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isComplete() {\n        return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);\n    }\n\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isLoading() {\n        return this._hasFlag(Resource.STATUS_FLAGS.LOADING);\n    }\n\n    /**\n     * Marks the resource as complete.\n     *\n     */\n    complete() {\n        this._clearEvents();\n        this._finish();\n    }\n\n    /**\n     * Aborts the loading of this resource, with an optional message.\n     *\n     * @param {string} message - The message to use for the error\n     */\n    abort(message) {\n        // abort can be called multiple times, ignore subsequent calls.\n        if (this.error) {\n            return;\n        }\n\n        // store error\n        this.error = new Error(message);\n\n        // clear events before calling aborts\n        this._clearEvents();\n\n        // abort the actual loading\n        if (this.xhr) {\n            this.xhr.abort();\n        }\n        else if (this.xdr) {\n            this.xdr.abort();\n        }\n        else if (this.data) {\n            // single source\n            if (this.data.src) {\n                this.data.src = Resource.EMPTY_GIF;\n            }\n            // multi-source\n            else {\n                while (this.data.firstChild) {\n                    this.data.removeChild(this.data.firstChild);\n                }\n            }\n        }\n\n        // done now.\n        this._finish();\n    }\n\n    /**\n     * Kicks off loading of this resource. This method is asynchronous.\n     *\n     * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n     */\n    load(cb) {\n        if (this.isLoading) {\n            return;\n        }\n\n        if (this.isComplete) {\n            if (cb) {\n                setTimeout(() => cb(this), 1);\n            }\n\n            return;\n        }\n        else if (cb) {\n            this.onComplete.once(cb);\n        }\n\n        this._setFlag(Resource.STATUS_FLAGS.LOADING, true);\n\n        this.onStart.dispatch(this);\n\n        // if unset, determine the value\n        if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n            this.crossOrigin = this._determineCrossOrigin(this.url);\n        }\n\n        switch (this.loadType) {\n            case Resource.LOAD_TYPE.IMAGE:\n                this.type = Resource.TYPE.IMAGE;\n                this._loadElement('image');\n                break;\n\n            case Resource.LOAD_TYPE.AUDIO:\n                this.type = Resource.TYPE.AUDIO;\n                this._loadSourceElement('audio');\n                break;\n\n            case Resource.LOAD_TYPE.VIDEO:\n                this.type = Resource.TYPE.VIDEO;\n                this._loadSourceElement('video');\n                break;\n\n            case Resource.LOAD_TYPE.XHR:\n                /* falls through */\n            default:\n                if (useXdr && this.crossOrigin) {\n                    this._loadXdr();\n                }\n                else {\n                    this._loadXhr();\n                }\n                break;\n        }\n    }\n\n    /**\n     * Checks if the flag is set.\n     *\n     * @private\n     * @param {number} flag - The flag to check.\n     * @return {boolean} True if the flag is set.\n     */\n    _hasFlag(flag) {\n        return (this._flags & flag) !== 0;\n    }\n\n    /**\n     * (Un)Sets the flag.\n     *\n     * @private\n     * @param {number} flag - The flag to (un)set.\n     * @param {boolean} value - Whether to set or (un)set the flag.\n     */\n    _setFlag(flag, value) {\n        this._flags = value ? (this._flags | flag) : (this._flags & ~flag);\n    }\n\n    /**\n     * Clears all the events from the underlying loading source.\n     *\n     * @private\n     */\n    _clearEvents() {\n        clearTimeout(this._elementTimer);\n\n        if (this.data && this.data.removeEventListener) {\n            this.data.removeEventListener('error', this._boundOnError, false);\n            this.data.removeEventListener('load', this._boundComplete, false);\n            this.data.removeEventListener('progress', this._boundOnProgress, false);\n            this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n        }\n\n        if (this.xhr) {\n            if (this.xhr.removeEventListener) {\n                this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n                this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n                this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n                this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n                this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n            }\n            else {\n                this.xhr.onerror = null;\n                this.xhr.ontimeout = null;\n                this.xhr.onprogress = null;\n                this.xhr.onload = null;\n            }\n        }\n    }\n\n    /**\n     * Finalizes the load.\n     *\n     * @private\n     */\n    _finish() {\n        if (this.isComplete) {\n            throw new Error('Complete called again for an already completed resource.');\n        }\n\n        this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);\n        this._setFlag(Resource.STATUS_FLAGS.LOADING, false);\n\n        this.onComplete.dispatch(this);\n    }\n\n    /**\n     * Loads this resources using an element that has a single source,\n     * like an HTMLImageElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n    _loadElement(type) {\n        if (this.metadata.loadElement) {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'image' && typeof window.Image !== 'undefined') {\n            this.data = new Image();\n        }\n        else {\n            this.data = document.createElement(type);\n        }\n\n        if (this.crossOrigin) {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource) {\n            this.data.src = this.url;\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n\n        if (this.timeout) {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n        }\n    }\n\n    /**\n     * Loads this resources using an element that has multiple sources,\n     * like an HTMLAudioElement or HTMLVideoElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n    _loadSourceElement(type) {\n        if (this.metadata.loadElement) {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n            this.data = new Audio();\n        }\n        else {\n            this.data = document.createElement(type);\n        }\n\n        if (this.data === null) {\n            this.abort(`Unsupported element: ${type}`);\n\n            return;\n        }\n\n        if (this.crossOrigin) {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource) {\n            // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n            if (navigator.isCocoonJS) {\n                this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n            }\n            else if (Array.isArray(this.url)) {\n                const mimeTypes = this.metadata.mimeType;\n\n                for (let i = 0; i < this.url.length; ++i) {\n                    this.data.appendChild(\n                        this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes)\n                    );\n                }\n            }\n            else {\n                const mimeTypes = this.metadata.mimeType;\n\n                this.data.appendChild(\n                    this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes)\n                );\n            }\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n        this.data.addEventListener('canplaythrough', this._boundComplete, false);\n\n        this.data.load();\n\n        if (this.timeout) {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n        }\n    }\n\n    /**\n     * Loads this resources using an XMLHttpRequest.\n     *\n     * @private\n     */\n    _loadXhr() {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string') {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xhr = this.xhr = new XMLHttpRequest();\n\n        // set the request type and url\n        xhr.open('GET', this.url, true);\n\n        xhr.timeout = this.timeout;\n\n        // load json as text and parse it ourselves. We do this because some browsers\n        // *cough* safari *cough* can't deal with it.\n        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n            xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n        }\n        else {\n            xhr.responseType = this.xhrType;\n        }\n\n        xhr.addEventListener('error', this._boundXhrOnError, false);\n        xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n        xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n        xhr.addEventListener('progress', this._boundOnProgress, false);\n        xhr.addEventListener('load', this._boundXhrOnLoad, false);\n\n        xhr.send();\n    }\n\n    /**\n     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n     *\n     * @private\n     */\n    _loadXdr() {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string') {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xdr = this.xhr = new XDomainRequest(); // eslint-disable-line no-undef\n\n        // XDomainRequest has a few quirks. Occasionally it will abort requests\n        // A way to avoid this is to make sure ALL callbacks are set even if not used\n        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n        xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n\n        xdr.onerror = this._boundXhrOnError;\n        xdr.ontimeout = this._boundXhrOnTimeout;\n        xdr.onprogress = this._boundOnProgress;\n        xdr.onload = this._boundXhrOnLoad;\n\n        xdr.open('GET', this.url, true);\n\n        // Note: The xdr.send() call is wrapped in a timeout to prevent an\n        // issue with the interface where some requests are lost if multiple\n        // XDomainRequests are being sent at the same time.\n        // Some info here: https://github.com/photonstorm/phaser/issues/1248\n        setTimeout(() => xdr.send(), 1);\n    }\n\n    /**\n     * Creates a source used in loading via an element.\n     *\n     * @private\n     * @param {string} type - The element type (video or audio).\n     * @param {string} url - The source URL to load from.\n     * @param {string} [mime] - The mime type of the video\n     * @return {HTMLSourceElement} The source element.\n     */\n    _createSource(type, url, mime) {\n        if (!mime) {\n            mime = `${type}/${this._getExtension(url)}`;\n        }\n\n        const source = document.createElement('source');\n\n        source.src = url;\n        source.type = mime;\n\n        return source;\n    }\n\n    /**\n     * Called if a load errors out.\n     *\n     * @param {Event} event - The error event from the element that emits it.\n     * @private\n     */\n    _onError(event) {\n        this.abort(`Failed to load element using: ${event.target.nodeName}`);\n    }\n\n    /**\n     * Called if a load progress event fires for an element or xhr/xdr.\n     *\n     * @private\n     * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n     */\n    _onProgress(event) {\n        if (event && event.lengthComputable) {\n            this.onProgress.dispatch(this, event.loaded / event.total);\n        }\n    }\n\n    /**\n     * Called if a timeout event fires for an element.\n     *\n     * @private\n     */\n    _onTimeout() {\n        this.abort(`Load timed out.`);\n    }\n\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnError() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request failed. Status: ${xhr.status}, text: \"${xhr.statusText}\"`);\n    }\n\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnTimeout() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request timed out.`);\n    }\n\n    /**\n     * Called if an abort event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnAbort() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request was aborted by the user.`);\n    }\n\n    /**\n     * Called when data successfully loads from an xhr/xdr request.\n     *\n     * @private\n     * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n     */\n    _xhrOnLoad() {\n        const xhr = this.xhr;\n        let text = '';\n        let status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n\n        // responseText is accessible only if responseType is '' or 'text' and on older browsers\n        if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {\n            text = xhr.responseText;\n        }\n\n        // status can be 0 when using the `file://` protocol so we also check if a response is set.\n        // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n        if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER)) {\n            status = STATUS_OK;\n        }\n        // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n        else if (status === STATUS_IE_BUG_EMPTY) {\n            status = STATUS_EMPTY;\n        }\n\n        const statusType = (status / 100) | 0;\n\n        if (statusType === STATUS_TYPE_OK) {\n            // if text, just return it\n            if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n                this.data = text;\n                this.type = Resource.TYPE.TEXT;\n            }\n            // if json, parse into json object\n            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n                try {\n                    this.data = JSON.parse(text);\n                    this.type = Resource.TYPE.JSON;\n                }\n                catch (e) {\n                    this.abort(`Error trying to parse loaded json: ${e}`);\n\n                    return;\n                }\n            }\n            // if xml, parse into an xml document or div element\n            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n                try {\n                    if (window.DOMParser) {\n                        const domparser = new DOMParser();\n\n                        this.data = domparser.parseFromString(text, 'text/xml');\n                    }\n                    else {\n                        const div = document.createElement('div');\n\n                        div.innerHTML = text;\n\n                        this.data = div;\n                    }\n\n                    this.type = Resource.TYPE.XML;\n                }\n                catch (e) {\n                    this.abort(`Error trying to parse loaded xml: ${e}`);\n\n                    return;\n                }\n            }\n            // other types just return the response\n            else {\n                this.data = xhr.response || text;\n            }\n        }\n        else {\n            this.abort(`[${xhr.status}] ${xhr.statusText}: ${xhr.responseURL}`);\n\n            return;\n        }\n\n        this.complete();\n    }\n\n    /**\n     * Sets the `crossOrigin` property for this resource based on if the url\n     * for this resource is cross-origin. If crossOrigin was manually set, this\n     * function does nothing.\n     *\n     * @private\n     * @param {string} url - The url to test.\n     * @param {object} [loc=window.location] - The location object to test against.\n     * @return {string} The crossOrigin value to use (or empty string for none).\n     */\n    _determineCrossOrigin(url, loc) {\n        // data: and javascript: urls are considered same-origin\n        if (url.indexOf('data:') === 0) {\n            return '';\n        }\n\n        // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n        // origin designed not to match window.location.origin, and will always require\n        // crossOrigin requests regardless of whether the location matches.\n        if (window.origin !== window.location.origin) {\n            return 'anonymous';\n        }\n\n        // default is window.location\n        loc = loc || window.location;\n\n        if (!tempAnchor) {\n            tempAnchor = document.createElement('a');\n        }\n\n        // let the browser determine the full href for the url of this resource and then\n        // parse with the node url lib, we can't use the properties of the anchor element\n        // because they don't work in IE9 :(\n        tempAnchor.href = url;\n        url = parseUri(tempAnchor.href, { strictMode: true });\n\n        const samePort = (!url.port && loc.port === '') || (url.port === loc.port);\n        const protocol = url.protocol ? `${url.protocol}:` : '';\n\n        // if cross origin\n        if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n            return 'anonymous';\n        }\n\n        return '';\n    }\n\n    /**\n     * Determines the responseType of an XHR request based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n     */\n    _determineXhrType() {\n        return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;\n    }\n\n    /**\n     * Determines the loadType of a resource based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.LOAD_TYPE} The loadType to use.\n     */\n    _determineLoadType() {\n        return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;\n    }\n\n    /**\n     * Extracts the extension (sans '.') of the file being loaded by the resource.\n     *\n     * @private\n     * @return {string} The extension.\n     */\n    _getExtension() {\n        let url = this.url;\n        let ext = '';\n\n        if (this.isDataUrl) {\n            const slashIndex = url.indexOf('/');\n\n            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n        }\n        else {\n            const queryStart = url.indexOf('?');\n            const hashStart = url.indexOf('#');\n            const index = Math.min(\n                queryStart > -1 ? queryStart : url.length,\n                hashStart > -1 ? hashStart : url.length\n            );\n\n            url = url.substring(0, index);\n            ext = url.substring(url.lastIndexOf('.') + 1);\n        }\n\n        return ext.toLowerCase();\n    }\n\n    /**\n     * Determines the mime type of an XHR request based on the responseType of\n     * resource being loaded.\n     *\n     * @private\n     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n     * @return {string} The mime type to use.\n     */\n    _getMimeFromXhrType(type) {\n        switch (type) {\n            case Resource.XHR_RESPONSE_TYPE.BUFFER:\n                return 'application/octet-binary';\n\n            case Resource.XHR_RESPONSE_TYPE.BLOB:\n                return 'application/blob';\n\n            case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n                return 'application/xml';\n\n            case Resource.XHR_RESPONSE_TYPE.JSON:\n                return 'application/json';\n\n            case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n            case Resource.XHR_RESPONSE_TYPE.TEXT:\n                /* falls through */\n            default:\n                return 'text/plain';\n        }\n    }\n}\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.STATUS_FLAGS = {\n    NONE:       0,\n    DATA_URL:   (1 << 0),\n    COMPLETE:   (1 << 1),\n    LOADING:    (1 << 2),\n};\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.TYPE = {\n    UNKNOWN:    0,\n    JSON:       1,\n    XML:        2,\n    IMAGE:      3,\n    AUDIO:      4,\n    VIDEO:      5,\n    TEXT:       6,\n};\n\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.LOAD_TYPE = {\n    /** Uses XMLHttpRequest to load the resource. */\n    XHR:    1,\n    /** Uses an `Image` object to load the resource. */\n    IMAGE:  2,\n    /** Uses an `Audio` object to load the resource. */\n    AUDIO:  3,\n    /** Uses a `Video` object to load the resource. */\n    VIDEO:  4,\n};\n\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\nResource.XHR_RESPONSE_TYPE = {\n    /** string */\n    DEFAULT:    'text',\n    /** ArrayBuffer */\n    BUFFER:     'arraybuffer',\n    /** Blob */\n    BLOB:       'blob',\n    /** Document */\n    DOCUMENT:   'document',\n    /** Object */\n    JSON:       'json',\n    /** String */\n    TEXT:       'text',\n};\n\nResource._loadTypeMap = {\n    // images\n    gif:        Resource.LOAD_TYPE.IMAGE,\n    png:        Resource.LOAD_TYPE.IMAGE,\n    bmp:        Resource.LOAD_TYPE.IMAGE,\n    jpg:        Resource.LOAD_TYPE.IMAGE,\n    jpeg:       Resource.LOAD_TYPE.IMAGE,\n    tif:        Resource.LOAD_TYPE.IMAGE,\n    tiff:       Resource.LOAD_TYPE.IMAGE,\n    webp:       Resource.LOAD_TYPE.IMAGE,\n    tga:        Resource.LOAD_TYPE.IMAGE,\n    svg:        Resource.LOAD_TYPE.IMAGE,\n    'svg+xml':  Resource.LOAD_TYPE.IMAGE, // for SVG data urls\n\n    // audio\n    mp3:        Resource.LOAD_TYPE.AUDIO,\n    ogg:        Resource.LOAD_TYPE.AUDIO,\n    wav:        Resource.LOAD_TYPE.AUDIO,\n\n    // videos\n    mp4:        Resource.LOAD_TYPE.VIDEO,\n    webm:       Resource.LOAD_TYPE.VIDEO,\n};\n\nResource._xhrTypeMap = {\n    // xml\n    xhtml:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    html:       Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n    // this should probably be fine.\n    tsx:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // images\n    gif:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    png:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    bmp:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpg:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpeg:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    tif:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    tiff:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    webp:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    tga:        Resource.XHR_RESPONSE_TYPE.BLOB,\n\n    // json\n    json:       Resource.XHR_RESPONSE_TYPE.JSON,\n\n    // text\n    text:       Resource.XHR_RESPONSE_TYPE.TEXT,\n    txt:        Resource.XHR_RESPONSE_TYPE.TEXT,\n\n    // fonts\n    ttf:        Resource.XHR_RESPONSE_TYPE.BUFFER,\n    otf:        Resource.XHR_RESPONSE_TYPE.BUFFER,\n};\n\n// We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\nResource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n\n/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n *\n * @ignore\n * @param {object} map - The map to set on.\n * @param {string} extname - The extension (or key) to set.\n * @param {number} val - The value to set.\n */\nfunction setExtMap(map, extname, val) {\n    if (extname && extname.indexOf('.') === 0) {\n        extname = extname.substring(1);\n    }\n\n    if (!extname) {\n        return;\n    }\n\n    map[extname] = val;\n}\n\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\nfunction reqType(xhr) {\n    return xhr.toString().replace('object ', '');\n}\n\n// Backwards compat\nif (typeof module !== 'undefined') {\n    module.exports.default = Resource; // eslint-disable-line no-undef\n}\n","/**\n * Smaller version of the async library constructs.\n *\n * @namespace async\n */\n\n/**\n * Noop function\n *\n * @ignore\n * @function\n * @memberof async\n */\nfunction _noop() { /* empty */ }\n\n/**\n * Iterates an array in series.\n *\n * @memberof async\n * @param {Array.<*>} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n */\nexport function eachSeries(array, iterator, callback, deferNext) {\n    let i = 0;\n    const len = array.length;\n\n    (function next(err) {\n        if (err || i === len) {\n            if (callback) {\n                callback(err);\n            }\n\n            return;\n        }\n\n        if (deferNext) {\n            setTimeout(() => {\n                iterator(array[i++], next);\n            }, 1);\n        }\n        else {\n            iterator(array[i++], next);\n        }\n    })();\n}\n\n/**\n * Ensures a function is only called once.\n *\n * @ignore\n * @memberof async\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\nfunction onlyOnce(fn) {\n    return function onceWrapper() {\n        if (fn === null) {\n            throw new Error('Callback was already called.');\n        }\n\n        const callFn = fn;\n\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\n/**\n * Async queue implementation,\n *\n * @memberof async\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\nexport function queue(worker, concurrency) {\n    if (concurrency == null) { // eslint-disable-line no-eq-null,eqeqeq\n        concurrency = 1;\n    }\n    else if (concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    let workers = 0;\n    const q = {\n        _tasks: [],\n        concurrency,\n        saturated: _noop,\n        unsaturated: _noop,\n        buffer: concurrency / 4,\n        empty: _noop,\n        drain: _noop,\n        error: _noop,\n        started: false,\n        paused: false,\n        push(data, callback) {\n            _insert(data, false, callback);\n        },\n        kill() {\n            workers = 0;\n            q.drain = _noop;\n            q.started = false;\n            q._tasks = [];\n        },\n        unshift(data, callback) {\n            _insert(data, true, callback);\n        },\n        process() {\n            while (!q.paused && workers < q.concurrency && q._tasks.length) {\n                const task = q._tasks.shift();\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                workers += 1;\n\n                if (workers === q.concurrency) {\n                    q.saturated();\n                }\n\n                worker(task.data, onlyOnce(_next(task)));\n            }\n        },\n        length() {\n            return q._tasks.length;\n        },\n        running() {\n            return workers;\n        },\n        idle() {\n            return q._tasks.length + workers === 0;\n        },\n        pause() {\n            if (q.paused === true) {\n                return;\n            }\n\n            q.paused = true;\n        },\n        resume() {\n            if (q.paused === false) {\n                return;\n            }\n\n            q.paused = false;\n\n            // Need to call q.process once per concurrent\n            // worker to preserve full concurrency after pause\n            for (let w = 1; w <= q.concurrency; w++) {\n                q.process();\n            }\n        },\n    };\n\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') { // eslint-disable-line no-eq-null,eqeqeq\n            throw new Error('task callback must be a function');\n        }\n\n        q.started = true;\n\n        if (data == null && q.idle()) { // eslint-disable-line no-eq-null,eqeqeq\n            // call drain immediately if there are no tasks\n            setTimeout(() => q.drain(), 1);\n\n            return;\n        }\n\n        const item = {\n            data,\n            callback: typeof callback === 'function' ? callback : _noop,\n        };\n\n        if (insertAtFront) {\n            q._tasks.unshift(item);\n        }\n        else {\n            q._tasks.push(item);\n        }\n\n        setTimeout(() => q.process(), 1);\n    }\n\n    function _next(task) {\n        return function next() {\n            workers -= 1;\n\n            task.callback.apply(task, arguments);\n\n            if (arguments[0] != null) { // eslint-disable-line no-eq-null,eqeqeq\n                q.error(arguments[0], task.data);\n            }\n\n            if (workers <= (q.concurrency - q.buffer)) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n\n            q.process();\n        };\n    }\n\n    return q;\n}\n","const _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n/**\n * Encodes binary into base64.\n *\n * @param {string} input The input data to encode.\n * @returns {string} The encoded base64 string\n */\nexport function encodeBinary(input) {\n    let output = '';\n    let inx = 0;\n\n    while (inx < input.length) {\n        // Fill byte buffer array\n        const bytebuffer = [0, 0, 0];\n        const encodedCharIndexes = [0, 0, 0, 0];\n\n        for (let jnx = 0; jnx < bytebuffer.length; ++jnx) {\n            if (inx < input.length) {\n                // throw away high-order byte, as documented at:\n                // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n                bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n            }\n            else {\n                bytebuffer[jnx] = 0;\n            }\n        }\n\n        // Get each encoded character, 6 bits at a time\n        // index 1: first 6 bits\n        encodedCharIndexes[0] = bytebuffer[0] >> 2;\n\n        // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n        encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);\n\n        // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n        encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);\n\n        // index 3: forth 6 bits (6 least significant bits from input byte 3)\n        encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n\n        // Determine whether padding happened, and adjust accordingly\n        const paddingBytes = inx - (input.length - 1);\n\n        switch (paddingBytes) {\n            case 2:\n                // Set last 2 characters to padding char\n                encodedCharIndexes[3] = 64;\n                encodedCharIndexes[2] = 64;\n                break;\n\n            case 1:\n                // Set last character to padding char\n                encodedCharIndexes[3] = 64;\n                break;\n\n            default:\n                break; // No padding - proceed\n        }\n\n        // Now we will grab each appropriate character out of our keystring\n        // based on our index array and append it to the output string\n        for (let jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {\n            output += _keyStr.charAt(encodedCharIndexes[jnx]);\n        }\n    }\n\n    return output;\n}\n\n// Backwards compat\nif (typeof module !== 'undefined') {\n    module.exports.default = encodeBinary; // eslint-disable-line no-undef\n}\n","// import Loader from './Loader';\n// import Resource from './Resource';\n// import * as async from './async';\n// import * as b64 from './b64';\n\n/* eslint-disable no-undef */\n\nconst Loader = require('./Loader').Loader;\nconst Resource = require('./Resource').Resource;\nconst async = require('./async');\nconst b64 = require('./b64');\n\n/**\n *\n * @static\n * @memberof Loader\n * @member {Class<Resource>}\n */\nLoader.Resource = Resource;\n\n/**\n *\n * @static\n * @memberof Loader\n * @member {Class<async>}\n */\nLoader.async = async;\n\n/**\n *\n * @static\n * @memberof Loader\n * @member {Class<encodeBinary>}\n */\nLoader.encodeBinary = b64;\n\n/**\n *\n * @deprecated\n * @see Loader.encodeBinary\n *\n * @static\n * @memberof Loader\n * @member {Class<encodeBinary>}\n */\nLoader.base64 = b64;\n\n// export manually, and also as default\nmodule.exports = Loader;\n\n// default & named export\nmodule.exports.Loader = Loader;\nmodule.exports.default = Loader;\n","import { Resource } from '../../Resource';\nimport { encodeBinary } from '../../b64';\n\nconst Url = window.URL || window.webkitURL;\n\n// a middleware for transforming XHR loaded Blobs into more useful objects\nexport function blobMiddlewareFactory() {\n    return function blobMiddleware(resource, next) {\n        if (!resource.data) {\n            next();\n\n            return;\n        }\n\n        // if this was an XHR load of a blob\n        if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {\n            // if there is no blob support we probably got a binary string back\n            if (!window.Blob || typeof resource.data === 'string') {\n                const type = resource.xhr.getResponseHeader('content-type');\n\n                // this is an image, convert the binary string into a data url\n                if (type && type.indexOf('image') === 0) {\n                    resource.data = new Image();\n                    resource.data.src = `data:${type};base64,${encodeBinary(resource.xhr.responseText)}`;\n\n                    resource.type = Resource.TYPE.IMAGE;\n\n                    // wait until the image loads and then callback\n                    resource.data.onload = () => {\n                        resource.data.onload = null;\n\n                        next();\n                    };\n\n                    // next will be called on load\n                    return;\n                }\n            }\n            // if content type says this is an image, then we should transform the blob into an Image object\n            else if (resource.data.type.indexOf('image') === 0) {\n                const src = Url.createObjectURL(resource.data);\n\n                resource.blob = resource.data;\n                resource.data = new Image();\n                resource.data.src = src;\n\n                resource.type = Resource.TYPE.IMAGE;\n\n                // cleanup the no longer used blob after the image loads\n                // TODO: Is this correct? Will the image be invalid after revoking?\n                resource.data.onload = () => {\n                    Url.revokeObjectURL(src);\n                    resource.data.onload = null;\n\n                    next();\n                };\n\n                // next will be called on load.\n                return;\n            }\n        }\n\n        next();\n    };\n}\n"],"sourceRoot":""}